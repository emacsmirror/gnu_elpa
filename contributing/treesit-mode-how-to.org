# File: contributing/treesit-mode-how-to.org

# | Copyright 2025 Free Software Foundation, Inc.
# |
# | This program is free software: you can redistribute it and/or modify
# | it under the terms of the GNU General Public License as published by
# | the Free Software Foundation, either version 3 of the License, or
# | (at your option) any later version.
# |
# | This program is distributed in the hope that it will be useful,
# | but WITHOUT ANY WARRANTY; without even the implied warranty of
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# | GNU General Public License for more details.
# |
# | You should have received a copy of the GNU General Public License
# | along with this program.  If not, see <http://www.gnu.org/licenses/>.
# |
# | Commentary:
# |   Guidelines for writting a major mode powered by tree-sitter

#+startup: showall

#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles-from-org.css"/>
#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles.css"/>
#+options: ^:{}
#+options: toc:nil
#+latex_header: \usepackage[margin=0.5in]{geometry}
#+latex_header: \usepackage{parskip}
#+latex_header: \usepackage{tocloft}
#+latex_header: \advance\cftsecnumwidth 0.5em\relax
#+latex_header: \advance\cftsubsecindent 0.5em\relax
#+latex_header: \advance\cftsubsecnumwidth 0.5em\relax

#+title: How to Create and Test an Emacs Tree-Sitter Major Mode
#+author: John Ciolfi
#+date: Jun-30-2025

* TODO

- [ ] Add sweep test for indent
      - (directory-files-recursively DIR "\\.m$")
      - On each file, check parse tree for ERROR nodes and see if it really has an error by running
        matlab/bin/arch/mlint and looking for "Parse error". If no parse error, then flag these as
        issues with the matlab tree-sitter.
      - Indent the file to see if matlab-ts-mode--indent-assert-rule fires
- [ ] Add test for comment handling
- [ ] Investigate [[https://www.gnu.org/software/emacs/manual/html_mono/ert.html][ERT]] and [[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]] testing
- [ ] When done
  + validate we replaced: matlab => LANGUAGE, .m => .lang, m-file => lang-file
  + double check our t-utils.el programatically insert it
  + programatically insert all tests?

* Guide to building a tree-sitter mode

This guide to building a *LANGUAGE-ts-mode* for /file.lang/ files was written for Emacs 30.1.

In creating a tree-sitter mode for a programming language, you have two options. You can leverage an
old-style existing mode via =(define-derived-mode LANGUAGE-ts-mode OLD-LANGUAGE-mode "LANGUAGE"
...)= and then override items such as font-lock and indent. The other approach is to create a new
LANGUAGE-ts-mode based on prog-mode which we recommend to eliminate coupling between the old-style
mode and the new tree-sitter mode.

#+begin_src emacs-lisp
 (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE" ...)
#+end_src

To create the mode, we recommend following this order:

1. *Font-lock*. We suggest doing this first, so that /file.lang/ is syntactically colored when
   viewing it.
2. *Indent*. Next we set up indentation so that you can edit /file.lang/ easily.
3. *Syntax table and comments*.
4. *Imenu*
5. *Navigation*. Set up treesit-defun-type-regexp and treesit-defun-name-function to enable
   navigation features like beginning-of-defun and end-of-defun

Perhaps the most important item is to write tests while creating the =LANGUAGE=ts-mode=. We provide
some example tests that are designed to be repurposed by your =LANGUAGE-ts-mode=. Avoid developing
the full fledged mode, then adding tests because if you are like the rest of us, you'll keep putting
off writing the tests which will make =LANGUAGE-ts=mode= very difficult to maintain.

Emacs has the testing frameworks, [[https://www.gnu.org/software/emacs/manual/html_node/ert/index.html][ERT, Emacs Lisp Regressing Testing.]] There is also the [[https://github.com/jorgenschaefer/emacs-buttercup/][Emacs
buttercup]] though this is non-ELPA. As you'll see below, the techniques I used don't rely on ERT in
some of the tests because I wanted it to be very easy to add tests.  For example, when writing a
font-lock test, all you should do is provide the =file.lang= and run the test. The test will see
there is no expected baseline to compare against, so it will generate one for you and ask you to
validate it. The expect baseline for =file.lang= is =file_expected.txt= and the contents of the
=file_expected.txt= is of same length of =file.lang=, where each character's face is encoded in a
signle character. This makes it very easy to lockdown the behavior of font-lock without having to
write lisp code to add the test. The same test strategy is used for other aspects of our
=LANGUAGE-ts-mode=.

* Syntax trees and queries

If you are not familiar with the concepts behind tree-sitter, see
https://tree-sitter.github.io/tree-sitter. Learn the notion of queries and try out queries in the
playground section of the site on one of the languages supported by the site. A good understanding
of the syntax tree and queires are required to implement a new tree-sitter major mode. You don't
need to understand how to implement a lanugage parser if one already exists, otherwise you'll need
to write a tree-sitter language parser.

The tree-sitter parser produces a syntax tree:

#+begin_example
  +-------+     +-----------------------------+
  |       |     |                             |
  | Emacs |<===>| libtree-sitter-LANUGAGE.EXT |
  |       |     |                             |
  +-------+     +-----------------------------+
#+end_example

The libtree-sitter-LANUAGE.EXT shared library (EXT = .so on Linux, .dll on Windows, or .dylib on
Mac) is used to create a syntax tree of LANUAGE:

#+begin_example
  LANUAGE program             Syntax Tree

   c = a + b                      =
                                /   \
                               c     +
                                   a   b
#+end_example

Each node in the syntax tree knows it start point and end point in the LANGUAGE program. The
parser is fast and incrementally updates as you type. The memory required to represent the syntax
tree is roughly 10 times the text size of the program being analyzed. However, the benefits of
tree sitter are highly accurate and fast syntax coloring (font-lock), indentation, code
navigation via syntactic expressions, etc.

* Documentation

 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html][Emacs manual: Parsing Program Source]]
 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Emacs manual: Parser-based Indentation]]

* libtree-sitter-LANGUAGE.EXT

Place the tree-sitter language library in =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT=
(EXT=.so on Linux, .dll on Windows, .dylib on Mac). There are other locations that this can
reside in, though =~/.emacs.d/tree-sitter/= is the default.

- You can grab the LANGUAGE.EXT from https://github.com/emacs-tree-sitter/tree-sitter-langs/releases
  and rename it to =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT=.

- You can build it using

  : M-x treesit-install-language-grammar

It is possible that =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT= was built incorrectly,
so we create the following to validate it, replacing LANGUAGE with your language name.

Next, create a basic LANGUAGE-ts-mode.el to validate your tree-sitter shared library is good.  If
your libtree-sitter-LANGUAGE.EXT was built incorrectly (e.g. wrong compiler version), the following
will likely hang.

#+begin_src emacs-lisp
  ;; Basic LANGUAGE-ts-mode.el

  (require 'treesit)

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files with tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)
      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)

#+end_src

Validate your LANGAUGE-ts-mode works. Create foo.txt containing valid LANGUAGE content, then open
foo.txt in Emacs and run:

: M-x LANGUAGE-ts-mode

You should now be able to use:

: M-x treesit-inspect-mode
: M-x treesit-explore-mode

* Debugging tips

- Incremental updates to your LANGUAGE-ts-mode

   As you update =LANUGAGE-ts-mode.el= you need to tell Emacs to pick up the updates. To do this,

    - Use *=C-x C-e=*. With the cursor =(point)= at the end of the syntatic expression of your *.el
      file and run =C-x C-e= (or =M-x eval-last-sexp=) to evaluate the sexp prior to the cursor
      point.

    - Alternatively, use *=C-M-x* (or =M-x eval-defun=). With the =(point)= in the =defvar=,
      =defcusom=, or =defface=, run =C-M-x= to evaluate it.

   Note: =M-x eval-buffer= will not reevaluate already defined =defvar='s, so you must use
   one of the above two to update a =defvar=.

- =M-x LANGUAGE-ts-mode=

 - After making updates to =LANGUAGE-ts-mode.el= and evaluating them, you run =M-x LANGUAGE-ts-mode=
   to re-load your mode in your =test.lang= file. For example, when writing the indent rules, you'll
   need to run =M-x LANGUAGE-ts-mode= after =M=x eval-defun= on in your =(defvar
   LANGUAGE-ts-mode--indent-rules ....)=.

- Use =M-x ielm=

  In the =*ielm*= buffer created by =M-x ielm=, you can examine tree-sitter nodes, etc. For example:

  #+begin_example
  ELISP> (with-current-buffer "test.lang"
	 (treesit-node-parent (treesit-node-at (point))))
  #+end_example

* Font-lock

Queries are needed to identify syntax tree nodes to semantically color language elements
(font-lock). See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-Matching.html][Emacs manual - Pattern Matching Tree-sitter Nodes]]. You can use =M-x
treesit-explore-mode= to see the nodes of the syntax tree.

An example of a query that identifies comments (assuming =comment= is a valid node type), in a
file that has =M-x LANGUAGE-ts-mode= active.

: M-: (treesit-query-capture (treesit-buffer-root-node) '((comment) @comments))

Suppose your lanugage contains the keyword "if", you can find all "if" keywords using:

: M-: (treesit-query-capture (treesit-buffer-root-node) '("if" @keywords))

To capture all keywords of your language, use alternation. Here we are capturing the "if"
and "else" keywords:

: M-: (treesit-query-capture (treesit-buffer-root-node) '(["if" "else"] @keywords))

Note, to validate your queries use:

: M-x (treesit-query-validate 'LANGUAGE '(QUERRY @catpture-name))

Once we know the queries, we can set up font-lock. For example, here we fontify comments
and keywords.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  (defvar LANGUAGE-ts-mode--keywords
    '("else"
      "if"
      "end"
      ;; <snip>
      )
    "The LANGUAGE-ts-mode font-lock keywords.")

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face))
  "The LANGUAGE tree-sitter font-lock settings.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock. See: ./tests/test-matlab-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)
  ;;; LANGUAGE-ts-mode.el ends here
#+end_src

Notice how the =@capture-name= in the comment query is =@font-lock-comment-face=. This face is
applied to the items captured by the query. You can see available faces by using =M-x
list-faces-display=.  You'll probably want to stick with faces that come with stock Emacs to avoid
dependencies on other packages or create your own face.

The =treesit-font-lock-feature-list= contains four sublists where the first sublist is font-lock
level 1, and so on. Each sublist contains a set of feature; names that correspond to the =:feature
'NAME= entries in =LANGUAGE-ts-mode--font-lock-settings=.  For example, ='comment= for comments,
='definition= for function and other definitions, ='keyword= for language keywords, etc. Font-lock
applies the faces defined in each sublist up to and including `treesit-font-lock-level', which
defaults to 3. If you'd like to have your font-lock default to level 4, add:

#+begin_src emacs-lisp
  (defcustom LANGUAGE-ts-font-lock-level 4
    "Level of font lock, 1 for minimum syntax highlighting and 4 for maximum."
    :type '(choice (const :tag "Minimal" 1)
  		 (const :tag "Low" 2)
  		 (const :tag "Standard" 3)
  		 (const :tag "Standard plus parse errors" 4)))

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"

    ;; <snip>
    (setq-local treesit-font-lock-level LANGUAGE-ts-font-lock-level)
    (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
    ;; <snip>
    )
#+end_src

** Font-lock Tests

It is recommended that you create tests to validate your font-lock set up and commit your tests with
your code together. This will make it easier for you and others to update your code without causing
regressions. Under our LANGUAGE-ts-mode.el, we create a tests subdirectory containing our tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/t-utils.el                                                // see "Appendix: t-utils.el"
  ./tests/test-LANGUAGE-ts-mode-font-lock.el
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt // generated for you
#+end_example

Where =tests/test-LANGUAGE-ts-mode-font-lock.el= is shown below. Notice that there's a
=code-to-face= table that assigns a character "code" to each face we are using. You may need to
update this table to meet your needs.

To add tests, create files of form
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang= and then

 : M-: (test-LANGUAGE-ts-mode-font-lock)

This will create =./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt~= and
after examining it, rename it to
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt=.

To run your tests in a build system, use

#+begin_src bash
  emacs --batch -Q --eval "(setq debug-on-error t)" -l test-runner.el -eval t-utils-run
#+end_src

#+begin_src emacs-lisp
  ;;; test-LANGUAGE-ts-mode-font-lock.el --- Test LANGUAGE-ts-mode font-lock -*- lexical-binding: t -*-

  ;;; Commentary:

  ;;; Code:

  (require 't-utils)
  (require 'language-ts-mode)

  (cl-defun test-language-ts-mode-font-lock (&optional lang-file)
    "Test font-lock using ./test-language-ts-mode-font-lock-files/NAME.lang.
  Compare ./test-language-ts-mode-font-lock-files/NAME.lang against
  ./test-language-ts-mode-font-lock-files/NAME_expected.txt, where
  NAME_expected.txt is of same length as NAME.lang where each source
  character in NAME.lang is replaced with a character code representing the
  font-lock face used for said source character.  The mapping is defined
  by the code-to-face alist setup by this function.  If LANG-FILE is not
  provided, loop comparing all
  ./test-language-ts-mode-font-lock-files/NAME.lang files.

  To add a test, create
    ./test-language-ts-mode-font-lock-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-language-ts-mode-font-lock-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-language-ts-mode-font-lock-files/NAME_expected.lang"

    (let ((test-name "test-language-ts-mode-font-lock"))
      (when (not (t-utils-is-treesit-available 'language test-name))
        (cl-return-from test-language-ts-mode-font-lock))

      (let* ((lang-files (t-utils-get-files (concat test-name "-files") "\\.lang$" nil lang-file))
             (code-to-face '(
                             ("b" . font-lock-bracket-face)
                             ("B" . font-lock-builtin-face)
                             ("c" . font-lock-comment-face)
                             ("C" . font-lock-comment-delimiter-face)
                             ("d" . default)
                             ("D" . font-lock-delimiter-face)
                             ("f" . font-lock-function-name-face)
                             ("h" . font-lock-doc-face)
                             ("k" . font-lock-keyword-face)
                             ("n" . font-lock-constant-face)
                             ("s" . font-lock-string-face)
                             ("P" . font-lock-property-name-face)
                             ("t" . font-lock-type-face)
                             ("v" . font-lock-variable-name-face)
                             ("w" . font-lock-warning-face)
                             )))
        (t-utils-test-font-lock test-name lang-files code-to-face))
      ;; return "success" for M-: (test-language-ts-mode-font-lock)
      "success"))

  (provide 'test-language-ts-mode-font-lock)
  ;;; test-language-ts-mode-font-lock.el ends here
#+end_src

* Indent

Tree-sitter indentation is defined by =treesit-simple-indent-rules=.  We create a variable
containing our N indent rules and tell tree-sitter about them. Notice that we create debug and
assert rules which are set up so that you can deploy them in production without any cost. The debug
rule is only added when =treesit--indent-verbose= is =t=. The assert rule should never be hit if
your rules cover all cases, thus it has no cost. The assert rule must be activated which we do in
the tests.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts--indent-debug-rule
    '((lambda (node parent bol)
        (message "-->N:%S P:%S BOL:%S GP:%S NPS:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-assert nil
    "Tests should set this to t to identify when we fail to find an indent rule.")

  (defvar LANGUAGE-ts-mode--indent-assert-rule
    '((lambda (node parent bol)
        (when LANGUAGE-ts-mode--indent-assert
          (error "Assert no indent rule for: N:%S P:%S BOL:%S GP:%S NPS:%S BUF:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node)
                 (buffer-name))))
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
      `((LANGUAGE
         (MATCHER-1 ANCHOR-1 OFFSET-1)
         (MATCHER-N ANCHOR-N OFFSET-N)))
      "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock. See: ./tests/test-matlab-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent. See: ./tests/test-matlab-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))
#+end_src

To write the indent rules, we need to define the /matcher/, /anchor/, and /offset/ of each rule as
explained in the Emacs manual, "[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-based Indentation]]".  The /matcher/ and /anchor/ are are
functions that take three arguments, tree-sitter =node=, tree-sitter =parent= node, and =bol=.  The
=node= can be nil when not in a node. For example, when you type return, RET, after a statement.
=bol= is the beginning-of-line buffer position. /matcher/ returns non-nil when the rule applies and
/anchor/ returns the buffer position, which along with /offset/ determines the indent level of the
line.

Let's take this basic example of our LANGUAGE, =if_else.lang= file

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

Running =M-x treesit-explore-mode= gives us:

#+begin_example
  (source_file
   (if_statement if
    condition: (comparison_operator (identifier) > (number))
    \n
    (block
     (assignment left: (identifier) =
      right: (binary_operator left: (identifier) * right: (number)))
     ;)
    (else_clause else \n
     (block
      (assignment left: (identifier) = right: (identifier))
      ;))
    end)
   \n)
#+end_example

We start with

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ((parent-is ,(rx bol "source_file" eol)) column-0 0)
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

We set

: M-: (setq treesit--indent-verbose t)

and then hit the =TAB= key on lines when vising our =if_else.lang= file:

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

If we type =TAB= on the if a > 1 we'll see

 : -->N:#<treesit-node if_statement in 1-48> P:#<treesit-node source_file in 1-49> BOL:1 GP:nil NPS:nil

This gives us our first rule, =((parent-is "source_file") column-0 0)= is the rule for the root
node, which in our LANGUAGE is "source_file" and says to sart on column 0.

If we type  =TAB= on the "b = a * 2" line in the following =if_else.lang= file.
we'll see in the =*Messages*= buffer we'll see in the =*Messages*= buffer:

 : -->N:#<treesit-node block in 14-24> P:#<treesit-node if_statement in 1-48> BOL:14 GP:#<treesit-node source_file in 1-49> NPS:#<treesit-node "

where point 14-24 is "b = a * 2" and we see it has a node named "block". Thus, we update we add to
our indent rules, =((node-is "block") parent 4)= and a couple more rules as shown below. Notice we
included a comment before each rule, which will aid in the long-term maintance of the code. If the
font-lock rules are complex, you may also want to add ";; F-Rule: description" comments to them.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ((parent-is ,(rx bol "source_file" eol)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ((node-is ,(rx bol "block" eol)) parent 4)
       ;; I-Rule: <TAB> else
       ((node-is ,(rx bol "else_clause" eol)) parent 0)
       ;; I-Rule: <TAB> end
       ((node-is ,(rx bol "end" eol)) parent 0)
       ;; I-Rule: Assert if no rule hit
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

*Tip*: =C-M-x= in our =defvar= and re-run =M-x LANGUAGE-ts-mode= file to pick up the new indent
rules.

*Tip*: If you look at the defintion, =M-x find-variable RET treesit-simple-indent-presets RET=, you
can see how the built-in /matchers/ and /anchors/ are written. From that, you can write your own as
needed.

We can simplify this because the "else_clause" and "end" nodes have the same indent rules
so we can combine them and also handle handle nested if-statements as shown below.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  ;;--------------------;;
  ;; Section: font-lock ;;
  ;;--------------------;;

  (defvar LANGUAGE-ts-mode--keywords
    '("else"
      "if"
      "end"
      ;; <snip>
      )
    "The LANGUAGE-ts-mode font-lock keywords.")

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face))
  "The LANGUAGE tree-sitter font-lock settings.")

  ;;-----------------;;
  ;; Section: Indent ;;
  ;;-----------------;;

  (defvar LANGUAGE-ts--indent-debug-rule
    '((lambda (node parent bol)
        (message "-->N:%S P:%S BOL:%S GP:%S NPS:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-assert nil
    "Tests should set this to t to identify when we fail to find an indent rule.")

  (defvar LANGUAGE-ts-mode--indent-assert-rule
    '((lambda (node parent bol)
        (when LANGUAGE-ts-mode--indent-assert
          (error "Assert no indent rule for: N:%S P:%S BOL:%S GP:%S NPS:%S BUF:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node)
                 (buffer-name))))
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ((parent-is ,(rx bol "source_file" eol)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ((node-is ,(rx bol "block" eol)) parent 4)
       ;; I-Rule: <TAB> if condition
       ;;         <TAB> else
       ;;         <TAB> end
       ((node-is ,(rx bol (or "if_statement" "else_clause" "end") eol)) parent 0)
       ;; I-Rule: Assert if no rule hit
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;---------------------------;;
  ;; Section: LANGUAGE-ts-mode ;;
  ;;---------------------------;;

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock. See: ./tests/test-matlab-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent. See: ./tests/test-matlab-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)
  ;;; LANGUAGE-ts-mode.el ends here
#+end_src

Following this process, we complete our our indent engine by adding more rules. As we develop
the rules, it is good to lockdown expected behavior with tests.

** Indent Tests

We use a similar pattern for our indent tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-indent.el
  ./tests/test-LANGUAGE-ts-mode-indent-files/font_lock_test1.lang
  ./tests/test-LANGUAGE-ts-mode-indent-files/font_lock_test1_expected.lang  // generated for you
#+end_example

where test-LANGUAGE-ts-mode-indent.el contains:

#+begin_src emacs-lisp
  ;;; test-LANGUAGE-ts-mode-indent.el --- Test LANGUAGE-ts-mode indent -*- lexical-binding: t -*-

  ;;; Commentary:

  ;;; Code:

  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (cl-defun test-LANGUAGE-ts-mode-indent (&optional lang-file)
    "Test indent using ./test-LANGUAGE-ts-mode-indent-files/NAME.lang.
  Compare indent of ./test-LANGUAGE-ts-mode-indent-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang.  Indent is done two
  ways as described in `t-utils-test-indent'.  If LANG-FILE is not provided,
  loop comparing all ./test-LANGUAGE-ts-mode-indent-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-indent-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang"

    (let ((test-name "test-LANGUAGE-ts-mode-indent")
          (LANGUAGE-ts-mode--indent-assert t))

      (when (not (t-utils-is-treesit-available 'LANGUAGE test-name))
        (cl-return-from test-LANGUAGE-ts-mode-font-lock))

      (let ((lang-files (t-utils-get-files (concat test-name "-files") "\\.lang$"
  					 "_expected\\.lang$" ;; skip our *_expected.lang baselines
  					 lang-file))
            (line-manipulator (lambda ()
                                ;; Workaround
                                ;; https://github.com/acristoffers/tree-sitter-LANGUAGE/issues/32
                                (goto-char (point-min))
                                (while (not (eobp))
                                  (let* ((node   (treesit-node-at (point)))
                                         (parent (and node (treesit-node-parent node))))
                                    (when (string= (treesit-node-type parent) "ERROR")
                                      (insert " ")))
                                  (forward-line)))))

        (t-utils-test-indent test-name lang-files line-manipulator)))
    ;; return "success" for M-: (test-LANGUAGE-ts-mode-font-lock)
    "success")

#+end_src

* Syntax Table

The Emacs "syntax table" is not related to the syntax tree created by tree-sitter. A syntax tree
represents the hierarchical structure of your source code, giving a structural blueprint of your
code.

Think of the syntax table as a "language character descriptor". The syntax table defines the
syntatic role of each character within the buffer containing your source code.  Characters are
assigned a syntax class which includes word characters, comment start, comment end, string
delimiters, opening and closing delimiters (e.g.  =(=, =)=, =[=, =]=, ={=, =}=), etc. The syntax
table enables natural code editing and navitagion capabilities. For example, the syntax table is
used by movement commands, e.g. =C-M-f", =M-x forward-sexp=, based on syntatic expressions (words,
symbols, or balanced expressions). The syntax table is used for parentheses matching. It enables
comment operations such as =M-;=, =M-x comment-dwim=.

Below is our minimal LANGUAGE-ts-mode.el with the syntax table and comment support added. Note, our
single-line comments are of form "% comment" and block comments are of form "%{ <lines> %}". This is
set up by using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Descriptors.html][Emacs Syntax Descriptors]]. This may seem a bit obscure, but it's very elegant for
comments that start or end with one or two characters. If you have more complex syntax needs, for
example you'd like to allow "// single-line comments" but not for URL's http://location you'll need
to =(setq-local syntax-propertize-function (syntax-properties-rules ("./\\(/+\\)" (1 "."))))=.  If
you have more complex needs you'll need to set syntax-propertize-function to a function that calls
=(put-text-property start-point end-point 'category CATEGORY)=.

Notice that in our =LANGUAGE-ts-mode= definition, we set up the syntax table and comments first.
This is good practice because these are fundamental to Emacs.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  ;;-----------------------;;
  ;; Section: Syntax table ;;
  ;;-----------------------;;

  (defvar LANGUAGE-ts-mode--syntax-table
    (let ((st (make-syntax-table (standard-syntax-table))))
      ;; Comment Handling:
      ;; 1. Single line comments: % text (single char start),
      ;;                          note includes "%{ text"
      ;; 2. Multiline comments:   %{
      ;;                            lines
      ;;                          %}
      (modify-syntax-entry ?%  "< 13"  st)
      (modify-syntax-entry ?{  "(} 2c" st)
      (modify-syntax-entry ?}  "){ 4c" st)
      (modify-syntax-entry ?\n ">"     st)

      ;; String Handling:
      ;;   Single quoted string: 'text'
      ;;   Double-quoted string: "text"
      (modify-syntax-entry ?'  "\"" st)
      (modify-syntax-entry ?\" "\"" st)

      ;; Words and Symbols include the underscore
      (modify-syntax-entry ?_  "_" st)

      ;; Punctuation:
      (modify-syntax-entry ?\\ "." st)
      (modify-syntax-entry ?\t " " st)
      (modify-syntax-entry ?+  "." st)
      (modify-syntax-entry ?-  "." st)
      (modify-syntax-entry ?*  "." st)
      (modify-syntax-entry ?/  "." st)
      (modify-syntax-entry ?=  "." st)
      (modify-syntax-entry ?<  "." st)
      (modify-syntax-entry ?>  "." st)
      (modify-syntax-entry ?&  "." st)
      (modify-syntax-entry ?|  "." st)

      ;; Parenthetical blocks:
      ;;   Note: these are in standard syntax table, repeated here for completeness.
      (modify-syntax-entry ?\(  "()" st)
      (modify-syntax-entry ?\)  ")(" st)
      (modify-syntax-entry ?\[  "(]" st)
      (modify-syntax-entry ?\]  ")[" st)
      (modify-syntax-entry ?{   "(}" st)
      (modify-syntax-entry ?}   "){" st)

      st)
    "The LANGUAGE-ts-mode syntax table.")

  ;;--------------------;;
  ;; Section: font-lock ;;
  ;;--------------------;;

  (defvar LANGUAGE-ts-mode--keywords
    '("else"
      "if"
      "end"
      ;; <snip>
      )
    "The LANGUAGE-ts-mode font-lock keywords.")

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face))
  "The LANGUAGE tree-sitter font-lock settings.")

  ;;-----------------;;
  ;; Section: Indent ;;
  ;;-----------------;;

  (defvar LANGUAGE-ts--indent-debug-rule
    '((lambda (node parent bol)
        (message "-->N:%S P:%S BOL:%S GP:%S NPS:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-assert nil
    "Tests should set this to t to identify when we fail to find an indent rule.")

  (defvar LANGUAGE-ts-mode--indent-assert-rule
    '((lambda (node parent bol)
        (when LANGUAGE-ts-mode--indent-assert
          (error "Assert no indent rule for: N:%S P:%S BOL:%S GP:%S NPS:%S BUF:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node)
                 (buffer-name))))
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ((parent-is ,(rx bol "source_file" eol)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ((node-is ,(rx bol "block" eol)) parent 4)
       ;; I-Rule: <TAB> if condition
       ;;         <TAB> else
       ;;         <TAB> end
       ((node-is ,(rx bol (or "if_statement" "else_clause" "end") eol)) parent 0)
       ;; I-Rule: Assert if no rule hit
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;---------------------------;;
  ;; Section: LANGUAGE-ts-mode ;;
  ;;---------------------------;;

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Syntax-table
      (set-syntax-table LANGUAGE-ts-mode--syntax-table)

      ;; Comments
      (setq-local comment-start      "%")
      (setq-local comment-end        "")
      (setq-local comment-start-skip "%\\s-+")

      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)
  ;;; LANGUAGE-ts-mode.el ends here
#+end_src

** Syntax Table Tests

We follow a similar pattern for writing syntax table tests.

#+begin_src emacs-lisp
  ;;; test-LANGUAGE-ts-mode-syntax-table.el --- -*- lexical-binding: t -*-

  ;;; Commentary:

  ;;; Code:

  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (cl-defun test-LANGUAGE-ts-mode-syntax-table (&optional lang-file)
    "Test syntax-table using ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang.
  Compare ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.txt, where
  NAME_expected.txt gives the `syntax-ppss` value of each character in
  NAME.lang.  If LANG-FILE is not provided, loop comparing all
  ./test-LANGUAGE-ts-mode-indent-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang"

    (let ((test-name "test-LANGUAGE-ts-mode-syntax-table"))
      (when (not (t-utils-is-treesit-available 'LANGUAGE test-name))
        (cl-return-from test-LANGUAGE-ts-mode-syntax-table))

      (let ((lang-files (t-utils-get-files (concat test-name "-files") "\\.lang$" nil lang-file)))
        (t-utils-test-syntax-table test-name lang-files)))
    
    ;; return "success" for M-: (test-LANGUAGE-ts-mode-font-lock)
    "success")

  (provide 'test-LANGUAGE-ts-mode-syntax-table)
  ;;; test-LANGUAGE-ts-mode-syntax-table.el ends here

#+end_src

* Fill paragraph, M-q

=M-q= is bound to =prog-fill-reindent-defun= from =prog-mode=, which when the point is in a comment
will fill the comment. If the point is in code it will indent the code. If the point is in a string,
M-q will fill the string like it's plain text, which can result in syntax errors. This is expected
behavior because one can then fix the syntax behaviors by adding appropriate string
continuations. There's no way to alter the string filling behavior besides using defadvice, which
you should not do.

If your syntax table correctly identifies comments and strings, then it M-q just works, though you
should still add tests to validate it works.  If you'd like tree-sitter nodes other than comments
and strings to be filled like plain text, you should add a =text= entry to =treesit-thing-settings=,
e.g. if nodeName1 and nodeName2 should be filled like plain text, use:

 #+begin_src emacs-lisp
 (defvar LANGAUAGE-ts-mode--thing-settings
  `((LANGUAGE
     (text ,(rx (or "nodeName1" "nodeName2"))))))
 #+end_src

and in defun of LANGUAGE-ts-mode, add =(setq-local treesit-thing-settings
LANGUAGE-ts-mode--thing-settings)= after you've setup your syntax table.

** Fill paragraph tests

TODO

* IMenu

Emacs =M-g i= (=M-x imenu=), makes it easy to jump to items in your file. If our mode populates
imenu with the location of the function definitions, we can quickly jump to them by name. You can
also leverage [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Which-Function.html][M-x which-function-mode]] to have Emacs display the imenu entry for the current point in
the mode line.

To populate imenu,

TODO

* Summary

Tree-sitter powered modes provide highly accurate syntax coloring, indentation, and other features.
In addition, tree-sitter modes are generally much more performant than the older-style regular
expression based modes, especially for a reasonably complex programming language.

A downside of a tree-sitter mode is that the necessary =libtree-sitter-LANGUAGE.EXT= shared library
files are not provided with the =NAME-ts-mode='s that are shipped with Emacs. For =NAME-ts-mode='s
that are installed via =M-x package-install LANGUAGE-ts-mode=, the corresponding
=libtree-sitter-LANUAGE.EXT= shared libraries are not installed.  You can have Emacs build
=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT= via =M-x treesit-install-language-grammar=, but
this can result in shared libraries that do not run correctly because of a compiler version mismatch
between what was used for Emacs and what was used to build =libtree-sitter-LANGUAGE.EXT=.

Another problem with =M-x treesit-install-language-grammar= is that it doesn't specify the
application binary interface (ABI) version when building. For example, Emacs 30.1 is at ABI 14
=(treesit-library-abi-version)=, and tree-sitter is at 15 and if you attempt to use what
=M-x treesit-install-language-grammar= creates, you'll see:

 : Warning (treesit): The installed language grammar for LANGUAGE cannot be located or has problems (version-mismatch): 15

Ideally, =M-x treesit-install-language-grammar= would be updated to do more error checking to
ensure the right compilers are in place and specify the ABI version. Something like:

 : tree-sitter generate --abi 14
 : gcc src/*.c -I./src -o ~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.so --shared -fPIC -Os

As of Jun-2025, for Emacs 30.1, you can copy the prebuilt shared library, LANGUAGE.EXT, from
https://github.com/emacs-tree-sitter/tree-sitter-langs and place it in
=~/.emacs.d/tree-sitter/libtree-sitter-LANUGAGE.EXT=. Note, Emacs will first look for
=libtree-sitter-LANGUAGE.EXT= in =treesit-extra-load-path=, then in subdirectory =tree-sitter= under
=user-emacs-directory= (=~/.emacs.d/tree-sitter/libtree-sitter-LANUGAGE.EXT=), then in the system
=/lib=.

These downsides are relatively minor compared with the benefits of a tree-sitter powered mode. It is
well worth writing a tree-sitter mode.

* Appendix: t-utils.el

#+begin_src emacs-lisp
  ;;; t-utils.el --- Test utilities -*- lexical-binding: t -*-
  ;;
  ;; Copyright 2025 Free Software Foundation, Inc.
  ;;
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  ;;

  ;;; Commentary:
  ;;
  ;; Test utilities used by test-*.el files.
  ;;

  ;;; Code:

  (require 'cl-seq)

  ;; Add abs-path of ".." to load-path so we can require packages from above us.
  (let* ((lf (or load-file-name (buffer-file-name (current-buffer))))
         (d1 (file-name-directory lf))
         (parent-dir (expand-file-name (file-name-directory (directory-file-name d1)))))
    (add-to-list 'load-path parent-dir t))

  (defun t-utils-trim ()
    "Trim trailing whitespace and lines with utf-8-unix encoding."
    (setq buffer-file-coding-system 'utf-8-unix)
    (let ((delete-trailing-lines t))
      (delete-trailing-whitespace (point-min) (point-max))))

  (defun t-utils-get-files (subdir base-regexp &optional skip-regexp file-to-use)
    "Return list of full paths, /path/to/SUBDIR/FILE.
  The FILE basenames returned match BASE-REGEXP.
  Files matching optional SKIP-REGEXP are ignored.
  Optional FILE-TO-USE narrow the list of full paths to that file
  and the result is a list of one file.

  For example,
    (t-utils-get-files \"test-LANGUAGE-ts-mode-files\"
                       \"*\\.lang$\" \"_expected\\.lang$\" file-to-use)
  will return a list of /path/to/test-NAME/*.lang files, skipping
  all *_expected.lang files when file-to-use is nil."

    (let ((files (cl-delete-if (lambda (file)
                                 (and skip-regexp
                                      (string-match skip-regexp file)))
                               (directory-files subdir t base-regexp))))
      (when file-to-use
        (let ((true-file-to-use (file-truename file-to-use)))
          (when (not (member true-file-to-use files))
            (if (file-exists-p true-file-to-use)
                (error "File %s, resolved to %s, is not a valid selection.
  It should be one of %S" file-to-use true-file-to-use files)
              (error "File %s does not exist" file-to-use)))
          (setq files (list true-file-to-use))))
      files))

  (defun t-utils-is-treesit-available (language test-name)
    "Is tree-sitter ready for LANGUAGE?
  If not available a message saying skipping TEST-NAME is displayed."
    (let ((available (and (>= emacs-major-version 30) ;; treesit package comes with Emacs 30
                          (progn
                            (require 'treesit)
                            (when (fboundp 'treesit-ready-p)
                              (treesit-ready-p language t))))))
      (when (not available)
        (message "skipping-test: %s - %S tree sitter not available." test-name language))
      available))

  (defun t-utils-run (&optional match)
    "Run test files in current directory matching regexp, MATCH.
  If optional MATCH is non-nil, only run test file names whose
  non-directory part matches the regexp, MATCH.  For example,
  \"^test-foo.*\\\\.el$\" would run tell t-run to run \"test-foo*.el$\"
  files.  The default MATCH is \"^test-.*\\\\.el$\""
    (when (not match)
      (setq match "^test-.*\\.el$"))

    (dolist (test-file (directory-files "." t match))
      (when (not (load-file test-file))
        (error "Failed to load %s" test-file))
      (let ((test-fun (intern
                       (replace-regexp-in-string "\\.el" "" (file-name-nondirectory test-file)))))
        (funcall test-fun))))

  (defun t-utils--took (start-time)
    "Return \"- took N seconds\".
  N is `current-time' minus START-TIME."
    (format "- took %.2f seconds" (float-time (time-subtract (current-time) start-time))))

  (defun t-utils-test-font-lock (test-name lang-files code-to-face)
    "Test font-lock using on each lang-file in LANG-FILES list.
  Foreach file in LANG-FILES compare the file against NAME_expected.txt, where
  NAME the file name minus the extension.  NAME_expected.txt is of same
  length as the file and has a character for each face setup by font-lock.
  CODE_TO_FACE is an alist where each elment is (CHAR . FACE).
  TEST-NAME is used when displaying messages.

  If NAME_expected.txt does not exists or doesn't match the results we
  got, a NAME_expected.txt~ will be generated.  After reviewing
  NAME_expected.txt~, you should rename it to NAME_expected.txt or fix
  your code and rerun the test.

  For example, suppose our LANG-FILE contains
      int foo(void) {
          return 1;
      }
  our NAME_expected.txt will contain:
      kkk fffDkkkkD b
          kkkkkk nD
      D
  where int and void are keywords, etc. and CODE-TO-FACE contains:
    \\='((\"b\" . font-lock-bracket-face)
      (\"d\" . default)
      (\"D\" . font-lock-delimiter-face)
      (\"f\" . font-lock-function-name-face)
      (\"k\" . font-lock-keyword-face)
      (\"n\" . font-lock-constant-face))"

    (let ((face-to-code (mapcar (lambda (pair)
                                  (cons (cdr pair) (car pair)))
                                code-to-face)))
      (dolist (lang-file lang-files)
        (save-excursion
          (let ((start-time (current-time)))
            (message "START: %s %s" test-name lang-file)

            (when (boundp 'treesit-font-lock-level)
              (setq treesit-font-lock-level 4))

            (find-file lang-file)

            ;; Force font lock to throw catchable errors.
            (font-lock-mode 1)
            (font-lock-flush (point-min) (point-max))
            (font-lock-ensure (point-min) (point-max))

            (goto-char (point-min))
            (let* ((got "")
                   (expected-file (replace-regexp-in-string "\\.[^.]+$" "_expected.txt"
                                                            lang-file))
                   (got-file (concat expected-file "~"))
                   (expected (when (file-exists-p expected-file)
                               (with-temp-buffer
                                 (insert-file-contents-literally expected-file)
                                 (buffer-string)))))
              (while (not (eobp))
                (let* ((face (if (face-at-point) (face-at-point) 'default))
                       (code (if (looking-at "\\([ \t\n]\\)")
                                 (match-string 1)
                               (cdr (assoc face face-to-code)))))
                  (when (not code)
                    (error "Face, %S, is not in code-to-face alist" face))
                  (setq got (concat got code))
                  (forward-char)
                  (when (looking-at "\n")
                    (setq got (concat got "\n"))
                    (forward-char))))

              (when (not (string= got expected))
                (let ((coding-system-for-write 'raw-text-unix))
                  (write-region got nil got-file))
                (when (not expected)
                  (error "Baseline for %s does not exists.  \
  See %s and if it looks good rename it to %s"
                         lang-file got-file expected-file))
                (when (= (length got) (length expected))
                  (let* ((diff-idx (1- (compare-strings got nil nil expected nil nil)))
                         (got-code (substring got diff-idx (1+ diff-idx)))
                         (got-face (cdr (assoc got-code code-to-face)))
                         (expected-code (substring expected diff-idx (1+ diff-idx)))
                         (expected-face (cdr (assoc expected-code code-to-face))))
                    (error "Baseline for %s does not match, got: %s, expected: %s.  \
  Difference at column %d: got code-to-face (\"%s\" . %S), expected code-to-face (\"%s\" . %S)"
                           lang-file got-file expected-file
                           diff-idx
                           got-code got-face
                           expected-code expected-face)))
                (error "Baseline for %s does not match, lengths are different, got: %s, expected: %s"
                       lang-file got-file expected-file))
              (kill-buffer))
            (message "PASS: %s %s %s" test-name lang-file (t-utils--took start-time)))))))

  (defun t-utils--test-indent-typing (lang-file lang-file-mode
                                                expected expected-file
                                                &optional line-manipulator)
    "Exercise indent by simulating the creation of LANG-FILE via typing.
  This compares the simulation of typing LANG-FILE against the
  EXPECTED content in EXPECTED-FILE

  The typing occurs in a buffer named \"typing__NAME.EXT\" where NAME.EXT
  is the basename of LANG-FILE.

  The typing buffer is initialized with the string-trim'd version of the
  non-empty lines of LANG-FILE.  If optional LINE-MANIPULATOR function is
  specified, it is called with the typing buffer as the current
  buffer.  LINE-MANIPULATOR should only adjust whitespace in the lines.  It
  should not add newlines to the buffer.  LINE-MANIPULATOR is called from
  within a `save-excursion', so your function doesn't need to do that.

  After initializating the typing buffer, it's mode is set to
  LANG-FILE-MODE.  Each line is then indented via `indent-for-tab-command'
  and blank lines are inserted by calling `newline'.`"

    (let* ((typing-lang-file-name (concat "typing__" (file-name-nondirectory lang-file)))
           (contents (with-temp-buffer
                       (insert-file-contents-literally lang-file)
                       (buffer-substring (point-min) (point-max))))
           (lines (split-string (string-trim contents) "\n")))
      (with-current-buffer (get-buffer-create typing-lang-file-name)
        (erase-buffer)
        (funcall lang-file-mode)

        ;; Insert the non-empty lines into typing-lang-file-name buffer
        (dolist (line lines)
          (setq line (string-trim line))
          (when (not (string= line ""))
            (insert line "\n")))

        (goto-char (point-min))

        (when line-manipulator
          (save-excursion
            (funcall line-manipulator)))

        ;; Now indent each line and insert the empty ("") lines into typing-lang-file-buffer
        ;; as we indent. This exercises the RET and TAB behaviors which cause different
        ;; tree-sitter nodes to be provided to the indent engine rules.
        (while (not (eobp))

          (call-interactively #'indent-for-tab-command) ;; TAB on code just added

          ;; While next line in our original contents is a newline insert "\n"
          (while (let ((next-line (nth (line-number-at-pos (point)) lines)))
                   (and next-line (string-match-p "^[ \t\r]*$" next-line)))
            (goto-char (line-end-position))
            ;; RET to add blank line
            (call-interactively #'newline)
            ;; TAB on the same blank line can result in different tree-sitter nodes than
            ;; the RET, so exercise that.
            (call-interactively #'indent-for-tab-command))
          (forward-line))

        (t-utils-trim)

        (let ((typing-got (buffer-substring (point-min) (point-max))))
          (set-buffer-modified-p nil)
          (kill-buffer)
          (when (not (string= typing-got expected))
            (let ((coding-system-for-write 'raw-text-unix)
                  (typing-got-file (replace-regexp-in-string "\\.\\([^.]+\\)$"
                                                             "_typing.\\1~"
                                                             lang-file)))
              (write-region typing-got nil typing-got-file)
              (error "Typing %s line-by-line does not match %s, we got %s" lang-file expected-file
                     typing-got-file)))))))

  (defun t-utils-test-indent (test-name lang-files &optional line-manipulator)
    "Test indent on each file in LANG-FILES list.
  Compare indent of each NAME.EXT in LANG-FILES against NAME_expected.EXT.
  TEST-NAME is used in messages.

  If NAME_expected.EXT does not exist or the indent of NAME.EXT doesn't
  match NAME_expected.txt, NAME_expected.EXT~ will be created.  You are
  then instructured to validate the indent and rename NAME_expected.EXT~
  to NAME_expected.EXT.

  To add a test for TEST-NAME.el, in it's corresponding TEST-NAME-files/
  directory, create TEST-NAME-files/NAME.EXT, then run the test.  Follow
  the messages to accept the generated baseline after validating it.

  Two methods are used to indent each file in LANG-FILES,
   1. (indent-region (point-min) (point-man))
   2. Simulation of typing lang-file to exercise TAB and RET,
      see `t-utils--test-indent-typing'.  In tree-sitter modes, TAB and RET
      need to be handled and this verifies they are handled.

  See `t-utils--test-indent-type' for LINE-MANIPULATOR."

    (dolist (lang-file lang-files)
      (let* ((expected-file (replace-regexp-in-string "\\.\\([^.]+\\)$" "_expected.\\1" lang-file))
             (expected (when (file-exists-p expected-file)
                         (with-temp-buffer
                           (insert-file-contents-literally expected-file)
                           (buffer-string))))
             lang-file-major-mode)
        
        ;; Indent lang-file
        (save-excursion
          (let ((start-time (current-time)))
            (message "START: %s <indent-region> %s" test-name lang-file)
            (find-file lang-file)
            (setq lang-file-major-mode major-mode)
            (indent-region (point-min) (point-max))
            (t-utils-trim)
            (let ((got (buffer-substring (point-min) (point-max)))
                  (got-file (concat expected-file "~")))
              (set-buffer-modified-p nil)
              (kill-buffer)
              (when (not (string= got expected))
                (let ((coding-system-for-write 'raw-text-unix))
                  (write-region got nil got-file))
                (when (not expected)
                  (error "Baseline for %s does not exists - if %s looks good rename it to %s"
                         lang-file got-file expected-file))
                (error "Baseline for %s does not match, got: %s, expected: %s"
                       lang-file got-file expected-file)))
            (message "PASS: %s <indent-region> %s %s" test-name lang-file
                     (t-utils--took start-time))))

        ;; Now, simulate typing lang-file and indent it (exercise TAB and RET)
        (let ((start-time (current-time)))
          (message "START: %s <indent-via-typing> %s" test-name lang-file)
          (t-utils--test-indent-typing lang-file lang-file-major-mode
                                       expected expected-file
                                       line-manipulator)
          (message "PASS: %s <indent-via-typing> %s %s" test-name lang-file
                   (t-utils--took start-time))))))

  (defun t-utils-test-syntax-table (test-name lang-files)
    "Test syntax-table on each file in LANG-FILES list.
  Compare syntax-table of each NAME.EXT in LANG-FILES against NAME_expected.txt.
  TEST-NAME is used in messages.

  If NAME_expected.txt does not exist or the syntax-table of NAME.txt doesn't
  match NAME_expected.txt, NAME_expected.txt~ will be created.  You are
  then instructured to validate the syntax-table and rename NAME_expected.txt~
  to NAME_expected.txt.

  To add a test for TEST-NAME.el, in it's corresponding TEST-NAME-files/
  directory, create TEST-NAME-files/NAME.EXT, then run the test.  Follow
  the messages to accept the generated baseline after validating it."

    (dolist (lang-file lang-files)
      (save-excursion
        (let ((start-time (current-time)))
          (message "START: %s %s" test-name lang-file)

          (find-file lang-file)
          (goto-char (point-min))

          (let* ((got "")
                 (expected-file (replace-regexp-in-string "\\.[^.]+$" "_expected.txt" lang-file))
                 (got-file (concat expected-file "~"))
                 (expected (when (file-exists-p expected-file)
                             (with-temp-buffer
                               (insert-file-contents-literally expected-file)
                               (buffer-string)))))
            (while (not (eobp))
              (when (looking-at "^")
                (setq got (concat got (format "Line:%d: %s\n"
                                              (line-number-at-pos)
                                              (buffer-substring-no-properties (point)
                                                                              (line-end-position))))))
              
              (let ((char (buffer-substring-no-properties (point) (1+ (point)))))
                (when (string= char "\n")
                  (setq char "\\n"))
                (setq got (concat got (format "  %2s: %S\n" char (syntax-ppss (point))))))

              (forward-char))

            (when (not (string= got expected))
              (let ((coding-system-for-write 'raw-text-unix))
                (write-region got nil got-file))
              (when (not expected)
                (error "Baseline for %s does not exists.  \
  See %s and if it looks good rename it to %s"
                       lang-file got-file expected-file))
              (error "Baseline for %s does not match, got: %s, expected: %s"
                     lang-file got-file expected-file))
            (kill-buffer))
          (message "PASS: %s %s %s" test-name lang-file (t-utils--took start-time))))))

  (provide 't-utils)
  ;;; t-utils.el ends here

#+end_src

* Issues

- [ ] Building libtree-sitter-matlab.dll from src on Windows produces a DLL that fails.

  - Install MSYS2
  - Run MSYS2 bash, then: pacman -S gcc
  - Install gpg from https://www.gpg4win.org/ and place it on on the path before MSYS2.
  - Install matlab tree sitter from src using Emacs 30.1
  #+begin_example
    emacs
    M-x treesit-install-language-grammar
    Language: matlab
    There is no recipe for matlab, do you want to build it interactively? (y or n) y
    Enter the URL of the Git repository of the language grammar: https://github.com/acristoffers/tree-sitter-matlab
    Enter the tag or branch (default: default branch): abi/14
    Enter the subdirectory in which the parser.c file resides (default: "src"):
    Enter the C compiler to use (default: auto-detect):
    Enter the C++ compiler to use (default: auto-detect):
    Install to (default: ~/.emacs.d/tree-sitter):
  #+end_example

  The resulting dll is bad. Maybe gcc 13 is not a valid version of gcc.

  Note the build of the dll from https://github.com/emacs-tree-sitter/tree-sitter-langs is good.

- [ ] In [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-Based Indentation]] we have prev-line which goes backward exactly one line

  Consider a programming lanugage with a few statements, e.g.

  #+begin_example
    {
        a = 1;
        b = 2;

    }
  #+end_example

  If you use prev-line on the blank-line immediately after "b = 2;", you'll get the expected
  point below "b". If you use prev-line on the second blank line after "b = 2;", you'll get
  0, which is unexpected in many languages. I suspect it may be safe to just update prev-real
  line too look backwards to the first prior line with non-whitespace or if you are worried
  about compatibility, introduce:

  #+begin_src emacs-lisp
    (cons 'prev-real-line (lambda (_n _p bol &rest _)
    			(save-excursion
    			  (goto-char bol)
    			  (forward-line -1)
    			  (while (and (not (bobp))
    				      (looking-at "^[ \t]*$"))
    			    (forward-line -1))
    			  (skip-chars-forward " \t")
    			  (point))))
  #+end_src

- [ ] M-q (prog-fill-reindent-defun), when the point is in a string and you type M-q it will
  split long strings into multiple lies which results in syntax errors in some languages, e.g. C.

  : char * str = "a very long string a very long string a very long string a very long string a very long string a very long string a very long string a very long string ";

  TODO validate this occurs with c-ts-mode.

  Would like an option to have M-q indent or fill comments. When in a string it should indent.
  Though ideally, it should correctly break the string into multiple lines so there's no semantic
  difference.
