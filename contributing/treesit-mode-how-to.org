# File: contributing/treesit-mode-how-to.org

# | Copyright (C) 2025 Free Software Foundation, Inc.
# |
# | This program is free software: you can redistribute it and/or modify
# | it under the terms of the GNU General Public License as published by
# | the Free Software Foundation, either version 3 of the License, or
# | (at your option) any later version.
# |
# | This program is distributed in the hope that it will be useful,
# | but WITHOUT ANY WARRANTY; without even the implied warranty of
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# | GNU General Public License for more details.
# |
# | You should have received a copy of the GNU General Public License
# | along with this program.  If not, see <http://www.gnu.org/licenses/>.
# |
# | Commentary:
# |   Guidelines for writing a major mode powered by tree-sitter

#+startup: showall

#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles-from-org.css"/>
#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles.css"/>
#+options: ^:{}
#+latex_header: \usepackage[margin=0.5in]{geometry}
#+latex_header: \usepackage{parskip}
#+latex_header: \usepackage{tocloft}
#+latex_header: \advance\cftsecnumwidth 0.5em\relax
#+latex_header: \advance\cftsubsecindent 0.5em\relax
#+latex_header: \advance\cftsubsecnumwidth 0.5em\relax

#+title: How to Create and Test an Emacs Tree-Sitter Major Mode
#+author: John Ciolfi
#+date: Sep-5-2025

I created this guide while developing, matlab-ts-mode, a [[https://tree-sitter.github.io/tree-sitter/][tree-sitter]] powered mode for [[https://www.mathworks.com][MATLAB]]. I
tried to make this guide general so it could be reused for creating major modes for other
languages.

I developed matlab-ts-mode using Emacs 30. The more I learned about tree-sitter, the more I liked
it. I was very much impressed with the quality of the tree-sitter itself and the integration of
tree-sitter in Emacs. The quality of the integration of tree-sitter in Emacs is exceptional.

* What does tree-sitter provide?

Tree-sitter provides a parse tree for your language in real-time. The tree-sitter parser for your
language is a highly efficient C shared library that is loaded into the Emacs process. Tree-sitter
updates the parse tree incrementally as you type in real-time. Errors are localized within the parse
tree. This means you can build a very accurate and highly performant major mode for your language
leveraging tree-sitter for:

 - Syntax highlighting.
 - Indenting as you type. This includes accurate indentation when there are syntax errors.
 - Semantic navigation. For example, go-to function start, go-to function end, and similar actions.
 - Imenu for navigation to function definitions or other items in your buffer.
 - Highlight of paired items, such as parentheses, brackets, braces, function start/end, and quotes.
 - Electric pair mode to automatically insert matching closing delimiters such as parentheses,
   brackets, braces, and quotes.

Tree-sitter differs from the Language Server Protocol, LSP. They both parse the source file but have
different objectives. LSP is a separate process and thus cannot do incremental parsing as you type
efficiently. LSP strength is that it does a deeper analysis of the source file. For example, with
languages like C/C++, LSP parses the include headers so it can provide go-to definition, find
references, diagnostics warning and error messages, and similar capabilities. These LSP capabilities
are not provided by tree-sitter, nor does it make sense for tree-sitter to provide them. It makes
perfect sense that Emacs provides both tree-sitter and LSP because they both provide complementary
capabilities for coding.

There is a small amount of overlap between LSP and tree-sitter in that both can provide indentation
(code formatting) and semantic highlighting. The advantage of tree-sitter is that it is faster and
more accurate indentation as you type. Another bonus is that tree-sitter works without requiring a
project or other setup to get things going. LSP requires typically requires the concept of a project
so it can parse your code. With tree-sitter, you can open a source file from anywhere and
tree-sitter can semantically color it, indent it, etc.

Try using LSP for syntax highlighting or code indentation on a large file where you type at a
productive speed of 40-75 words per minute. The experience will be less than ideal. Now try that
where syntax highlighting and code indentation are powered by tree-sitter. You'll be pleasantly
surprised how good tree-sitter is. The editor will be much smoother with higher-quality syntax
highlighting and code indentation. You see spend much less time having to adjust whitespace to
make your code look good because the indentation as you type is much better.

* Guide to building a tree-sitter mode

In creating a tree-sitter mode, *LANGUAGE-ts-mode* for /file.lang/ files, you have two options. You
can leverage an old-style existing mode via =(define-derived-mode LANGUAGE-ts-mode OLD-LANGUAGE-mode
"LANGUAGE" ...)= and then override items such as font-lock and indent. The other approach is to
create a new LANGUAGE-ts-mode based on prog-mode which we recommend. Taking this approach eliminates
unnecessary coupling between the old-style mode and the new tree-sitter mode.

#+begin_src emacs-lisp
 (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE" ...)
#+end_src

To create the mode, we recommend following this order:

1. *Font-lock*. Do this first, so that /file.lang/ is syntactically colored when viewing it.
2. *Indent*. Next set up indentation so that you can edit /file.lang/ easily.
3. *Syntax table and comments*.
4. *Imenu*
5. *Navigation*. Set up treesit-defun-type-regexp and treesit-defun-name-function to enable
   navigation features like beginning-of-defun and end-of-defun
6. *Others*. In the sections below, you will see additional items to polish off your tree-sitter
   major mode.

Writing tests as you develop your =LANGUAGE-ts-mode= will speed up the creation of the mode and
payoff nicely when making future updates to the mode. To add tests, you can leverage test
infrastructure described below for your =LANGUAGE-ts-mode=. Avoid developing the full-fledged mode,
then adding tests because if you are like the rest of us, you'll keep putting off writing the tests
which will make =LANGUAGE-ts=mode= very difficult to maintain. The key is to write tests as you
develop your =LANGUAGE-ts-mode=.

Emacs has the testing frameworks, [[https://www.gnu.org/software/emacs/manual/html_node/ert/index.html][ERT, Emacs Lisp Regressing Testing.]] There is also the [[https://github.com/jorgenschaefer/emacs-buttercup/][Emacs
buttercup]] though this is non-ELPA. To make creation and testing of the major mode easy, fast, and
efficient, I built [[file:~/emacs-projects/Emacs-MATLAB-Mode/tests/t-utils.el][t-utils.el]] that leverages ERT and adds looping capabilities, baseline file
generation, ability to skip test cases, execute-and-record capabilities, and sweep test
capabilities. See the comments at the start of [[file:~/emacs-projects/Emacs-MATLAB-Mode/tests/t-utils.el][t-utils.el]] to get a better sense of how
to leverage it. With these extra capabilities, it is very fast to author high-coverage tests. For
example, when writing a font-lock test, you provide the =file.lang= and run the test. The test will
see there is no expected baseline to compare against, so it will generate one for you and ask you to
validate it. The expect baseline for =file.lang= is =file_expected.txt= and the contents of the
=file_expected.txt= is of same length of =file.lang=, where each character's face is encoded in a
single character. This makes it very easy to lock down the behaviour of font-lock without having to
write lisp code to add the expected results of the test. The same test strategy is used for other
aspects of our =LANGUAGE-ts-mode=.

* Major Mode Conventions

Start by reading [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Major-Mode-Conventions.html][Emacs Major Mode Conventions]], with the following exceptions:

- Do not use kill-all-local-variables because the *-ts-mode.el shipped with Emacs do not use that.
- Do not set major-mode to 'LANGUAGE-ts-mode, this is set by =(treesit-parser-create 'LANGUAGE)=
- Do not set indent-line-function, we'll do that using treesit
- Do not set font-lock-defaults, we'll do that using treesit
- Do not use make-local-variable, instead use setq-local
- Do not set a mode hook, this is done for you by treesit

* Syntax trees and queries

If you are not familiar with the concepts behind tree-sitter, see
https://tree-sitter.github.io/tree-sitter. Learn the notion of queries and try out queries in the
playground section of the site on one of the languages supported by the site. A good understanding
of the syntax tree and queries are required to implement a new tree-sitter major mode. You don't
need to understand how to implement a language parser if one already exists, otherwise you'll need
to write a tree-sitter language parser.

The tree-sitter parser produces a syntax tree:

#+begin_example
  +-------+     +------------------------------+   shared library,
  |       |     |                              |   SLIB = .so    on Linux
  | Emacs |<===>| libtree-sitter-LANGUAGE.SLIB |          .dll   on Windows
  |       |     |                              |          .dylib on Mac
  +-------+     +------------------------------+
#+end_example

The libtree-sitter-LANGUAGE.SLIB shared library is used to create a syntax tree of LANGUAGE:

#+begin_example
  LANGUAGE program             Syntax Tree

   c = a + b                      =
                                /   \
                               c     +
                                   a   b
#+end_example

Each node in the syntax tree knows it start point and end point in the LANGUAGE program. The
parser is fast and incrementally updates as you type. The memory required to represent the syntax
tree is roughly 10 times the text size of the program being analyzed. However, the benefits of
tree sitter are highly accurate and fast syntax coloring (font-lock), indentation, code
navigation via syntactic expressions, etc.

* Documentation

 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html][Emacs manual: Parsing Program Source]]
 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Emacs manual: Parser-based Indentation]]
 - [[https://archive.casouri.cc/note/2024/emacs-30-tree-sitter/][Notes: Tree-sitter Changes in Emacs 30]]

* libtree-sitter-LANGUAGE.SLIB

Place the tree-sitter language library the =tree-sitter= subdirectory under =user-emacs-directory=,
which is typically =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB= (SLIB=.so on Linux, .dll on
Windows, .dylib on Mac). Note, there are other locations that this can reside in, see
=treesit-extra-load-path=, and the your operation system library locations (e.g. =/lib=).

- You can grab the LANGUAGE.SLIB from
  https://github.com/emacs-tree-sitter/tree-sitter-langs/releases and rename it to
  =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=.

- You can build it using

  : M-x treesit-install-language-grammar

Building tree-sitter using treesit-install-language-grammar may fail. For example, as of Sep-2025
Emacs 30 uses the tree-sitter application binary interface (ABI) version 14, yet the latest
tree-sitter ABI is 15 and the install doesn't build it correctly.



It is possible that =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB= was built incorrectly.
Therefore, you should create a basic =LANGUAGE-ts-mode.el= to validate your tree-sitter shared library
is good.  If your libtree-sitter-LANGUAGE.SLIB was built incorrectly (e.g. wrong compiler version),
the following will likely hang.

#+begin_src emacs-lisp
  ;; Basic LANGUAGE-ts-mode.el

  (require 'treesit)

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files with tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)
      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)

#+end_src

Validate your LANGUAGE-ts-mode works. Create foo.lang (where .lang is the extension used by your
language) containing valid LANGUAGE content, then open foo.txt in Emacs and run:

: M-x LANGUAGE-ts-mode

You should now be able to use:

: M-x treesit-inspect-mode
: M-x treesit-explore-mode

* Debugging tips

As you update =LANGUAGE-ts-mode.el= you need to tell Emacs to pick up the updates. To do this,
you can

- Incrementally evaluate your changes to =LANGUAGE-ts-mode.el=


    - Use =C-x C-e=. With the cursor =(point)= at the end of the syntactic expression in your
      file and run =C-x C-e= (or =M-x eval-last-sexp=) to evaluate the sexp prior to the cursor
      point. The =C-x C-e= binding is very helpful with the =(t-utils-xr ....)= macros
      you place in your NAME.LANG test files.

    - Use =C-M-x= (or =M-x eval-defun=). With the =(point)= in the
      =defun=, =defvar=, =defcusom=, =defface=, etc. run =C-M-x= to evaluate it.

    - Use =C-u C-M-x= within a =defun= to EDebug it.

- Full re-evaluation of =LANGUAGE-ts-mode.el= leveraging [[file:eval-buffer-fully.el][./eval-buffer-full.el]], you
  can:

    : M-x eval-buffer-fully

  =M-x eval-buffer= will only re-evaluate defun definitions. It will not reevaluate already
  defined =defvar=, =defvar-local=, and =defface= definitions. You can use =C-x C-e= or =C-M-x= on
  each updated definition to re-evaluate them.

- =M-x LANGUAGE-ts-mode=

 - After making updates to =LANGUAGE-ts-mode.el= and evaluating them, you run =M-x LANGUAGE-ts-mode=
   to re-load your mode in your =test.lang= file. For example, when writing the indent rules, you'll
   need to run =M-x LANGUAGE-ts-mode= after =M=x eval-defun= on in your =(defvar
   LANGUAGE-ts-mode--indent-rules ....)=.

- =M-: (treesit-.....)=

  You can use =M-:= or =M-x eval-expression= to evaluate expressions while visiting =file.lang=.
  For example, you can find the parent of a node at point:

  : M-: (treesit-node-parent (treesit-node-at (point))

  To find the available functions and view their help, you can run =C-h f treesit-<TAB>=.

- Use =M-x ielm=

  In the =*ielm*= buffer created by =M-x ielm=, you can examine tree-sitter nodes, etc. For example:

  #+begin_example
  ELISP> (with-current-buffer "test.lang"
           (treesit-node-parent (treesit-node-at (point))))
  #+end_example

- Additional tree-sitter inspection functions for debugging

  [[file:ts-inspect.el]] provides

  1. ts-inspect-point

     : M-: (ts-inspect-point)

     Display information about node at POSITION. \\
     POSITION defaults to the current point.
     Returns a string of the form:
       : Hierarchy:
       :   #<treesit-node ROOT in 1-67>
       :     #<treesit-node PARENT in 37-62>
       :       #<treesit-node NODE in 61-62>
       : Prev-siblings:
       :   > #<treesit-node PREV-SIBLING2 in 59-60>
       :     > #<treesit-node PREV-SIBLING1 in 60-61>
       :       > #<treesit-node NODE in 61-62>

* Setup: Font-lock

Tree-sitter queries are used to identify syntax tree nodes to semantically color language elements
(font-lock). See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-Matching.html][Emacs manual - Pattern Matching Tree-sitter Nodes]]. You can use =M-x
treesit-explore-mode= to see the nodes of the syntax tree.

An example of a query that identifies comments, assuming =comment= is the node type for comments,
in a file that has =M-x LANGUAGE-ts-mode= active.

: M-: (treesit-query-capture (treesit-buffer-root-node) '((comment) @comments))

Suppose your language contains the keyword "if", you can find all "if" keywords using:

: M-: (treesit-query-capture (treesit-buffer-root-node) '("if" @keywords))

To capture all keywords of your language, use alternation. Here we are capturing the "if" and "else"
keywords:

: M-: (treesit-query-capture (treesit-buffer-root-node) '(["if" "else"] @keywords))

Note, to validate your queries use:

: M-x (treesit-query-validate 'LANGUAGE '(QUERY @capture-name))

Once we know the queries, we can set up font-lock. For example, here we fontify comments, keywords,
and within comments we highlight to do markers.

As you are developing your font-lock rules, you should enable

 : M-: (setq treesit--font-lock-verbose t)

This will display messages of the following form which can be helpful in debugging.

 : Fontifying text from START-POINT to END-POINT, Face: FACE, Node: TYPE

Another debugging tip is to use the =%S= format specifier in calls to message which displays the
lisp object representation.  For example, in our defun LANGUAGE-ts-mode--comment-to-do-capture, we
could add =(message "debug comment-node: %S" comment-node)= which will show what it's processing.
Using EDebug on font-lock functions can be tricky because they get called on display updates.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  (defvar LANGUAGE-ts-mode--keywords
    '("else"
      "if"
      "end"
      ;; <snip>
      )
    "The LANGUAGE-ts-mode font-lock keywords.")

  (defun LANGUAGE-ts-mode--comment-to-do-capture (comment-node override start end &rest _)
    "Fontify comment to do, fix me, and triple-x markers.
  COMMENT-NODE is the tree-sitter comment node from a
  treesit-font-lock-rules rule and OVERRIDE is from that rule.  START and
  END specify the region to be fontified which could be smaller or larger
  than the COMMENT-NODE start-point and end-point."
    (save-excursion
      (let ((comment-end (treesit-node-end comment-node)))
        (goto-char (treesit-node-start comment-node))
        (while (< (point) comment-end)
          ;; Note, the markers below have spaces in them so we don't find them when searching "C-s"
          ;; while editing this file.
          (if (re-search-forward (rx word-start (group (or (seq "to" "do")
                                                           (seq "fix" "me")
                                                           (seq "x" "xx")))
                                     word-end)
                                 comment-end t)
              (let ((keyword-start (match-beginning 1))
                    (keyword-end (match-end 1)))
                (treesit-fontify-with-override keyword-start keyword-end
                                               'LANGUAGE-ts-mode-comment-to-do-marker-face
                                               override start end))
            (goto-char comment-end))))))

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules

     ;; F-Rule: Comments and line continuation: ... optional text
     ;; See: tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_comments.lang
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     ;; F-Rule: to do, fix me, triple-x marker comment keywords
     ;; See: test-LANGUAGE-ts-mode-font-lock-files/font_lock_comment_markers.lang
     :language 'matlab
     :feature 'comment-marker
     :override t
     '(((comment) @LANGUAGE-ts-mode--comment-to-do-capture))

     ;; F-Rule: keywords: if, else, etc.
     ;; See: tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_keywords.lang
     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face))
    "The LANGUAGE tree-sitter font-lock settings.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock.
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
                                                   (keyword string type)
                                                   (number bracket delimiter)
                                                   (syntax-error)))

      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)
  ;;; LANGUAGE-ts-mode.el ends here
#+end_src

Notice how the =@capture-name= in the comment query is =@font-lock-comment-face=. This face is
applied to the items captured by the query. You can see available faces by using =M-x
list-faces-display=.  You'll probably want to stick with faces that come with stock Emacs to avoid
dependencies on other packages or create your own face.

Within =LANGUAGE-ts-mode--font-lock-settings= we added comments of for ";; F-Rule: description"
which include a reference to a test.  You may wish to consider adding these comments. It will help
others when trying to understand what rules do and make your code more maintainable. We use
a unique string to start the comments, so they are searchable.

The =treesit-font-lock-feature-list= contains four sublists where the first sublist is font-lock
level 1, and so on. Each sublist contains a set of feature; names that correspond to the =:feature
'NAME= entries in =LANGUAGE-ts-mode--font-lock-settings=.  For example, ='comment= for comments,
='definition= for function and similar definitions', ='keyword= for language keywords, etc. Font-lock
applies the faces defined in each sublist up to and including `treesit-font-lock-level', which
defaults to 3. If you'd like to have your font-lock default to level 4, add:

#+begin_src emacs-lisp
  (defcustom LANGUAGE-ts-mode-font-lock-level 3
    "*Level of font lock, 1 for minimal syntax highlighting and 4 for maximum."
    ;; Setting to 4 to results in parse errors causing too much "red". See 'syntax-error
    ;; font-lock feature below.
    :type '(choice (const :tag "Minimal" 1)
  		 (const :tag "Low" 2)
  		 (const :tag "Standard" 3)
  		 (const :tag "Standard plus parse errors" 4)))

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"

    ;; <snip>
    (setq-local treesit-font-lock-level LANGUAGE-ts-font-lock-level)
    (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
    ;; <snip>
    )
#+end_src

** Test: Font-lock

It is recommended that you create tests to validate your font-lock set up and commit your tests with
your code together. This will make it easier for you and others to update your code without causing
regressions. Under our LANGUAGE-ts-mode.el, we create a tests subdirectory containing our tests that
leverages [[file:~/emacs-projects/Emacs-MATLAB-Mode/tests/t-utils.el][t-utils.el]]. See the comments at the start of t-utils.el to get a better sense of how
to leverage it.

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/t-utils.el
  ./tests/test-LANGUAGE-ts-mode-font-lock.el
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt // generated for you
#+end_example

Where =tests/test-LANGUAGE-ts-mode-font-lock.el= is shown below. Notice that there's a
=code-to-face= table that assigns a character "code" to each face we are using. You may need to
update this table to meet your needs.

To add tests, create files of form
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang= and then

 : M-x ert
 : Run tests: test-LANGUAGE-ts-mode-font-lock

This will create =./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt~= and
after examining it, rename it to
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt=.

When you run ert interactively, you'll be presented with a =*ert*= buffer. You can
type "m" on the colored dots in the =*ert*= buffer to see the messages for that ert test
and the messages contain the sub-tests from the test loop for that ert test.  This will bring
up an =*ERT Messages*= buffer.  In this buffer, type
  : M-x compilation-minor-mode
to view the and navigate errors.

To run your tests in a build system, use

#+begin_src bash
  emacs --batch -Q -l t-utils -eval t-utils-run
#+end_src

#+begin_src emacs-lisp
   (require 't-utils)
   (require 'language-ts-mode)

   (defvar test-LANGUAGE-ts-mode-font-lock--file nil)

   (defun test-LANGUAGE-ts-mode-font-lock--file (lang-file)
     "Test an individual LANG-FILE.
   This is provided for debugging.
     M-: (test-LANGUAGE-ts-mode-font-lock--file \"test-LANGUAGE-ts-mode-font-lock-files/LANG-FILE\")"
     (let ((test-LANGUAGE-ts-mode-font-lock--file lang-file))
       (ert-run-tests-interactively "test-LANGUAGE-ts-mode-font-lock")))

   (ert-deftest test-LANGUAGE-ts-mode-font-lock ()
     "Test font-lock.
   Compare font of ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang against
   ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt, where
   NAME_expected.txt is of same length as NAME.lang where each source
   character in NAME.lang is replaced with a character code representing the
   font-lock face used for said source character.  The mapping is defined
   by the code-to-face alist setup by this function.  This loops
   on all ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang files.

   To add a test, create
     ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang
   and run this function.  The baseline is saved for you as
     ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt~
   after validating it, rename it to
     ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt"

     (let* ((test-name "test-LANGUAGE-ts-mode-font-lock")
            (LANGUAGE-ts-mode-font-lock-level 4)
            (lang-files (t-utils-get-files
                      test-name
                      (rx ".lang" eos)
                      nil
                      test-LANGUAGE-ts-mode-font-lock--file))
            (code-to-face '(
                            ("b" . font-lock-bracket-face)
                            ("B" . font-lock-builtin-face)
                            ("c" . font-lock-comment-face)
                            ;; <add-more-as-needed>
                            )))
       (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
       (t-utils-test-font-lock test-name lang-files
  			     :code-to-face code-to-face)))
#+end_src

* Setup: Indent

Tree-sitter indentation is defined by =treesit-simple-indent-rules=.  We create a variable
containing our N indent rules and tell tree-sitter about them. Notice that we create debug and
assert rules which are set up so that you can deploy them in production without any cost. The debug
rule is only added when =treesit--indent-verbose= is =t=. The assert rule should never be hit if
your rules cover all cases, thus it has no cost. The assert rule must be activated which we do in
the tests.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts--indent-debug-rule
    '((lambda (node parent bol)
        (message "-->N:%S P:%S L:%d BOL:%S GP:%S NPS:%S"
                 node parent (line-number-at-pos) bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-assert nil
    "Tests should set this to t to identify when we fail to find an indent rule.")

  (defvar LANGUAGE-ts-mode--indent-assert-rule
    '((lambda (node parent bol)
        (when LANGUAGE-ts-mode--indent-assert
          (error "Assert no indent rule for: N:%S P:%S BOL:%S GP:%S NPS:%S BUF:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node)
                 (buffer-name))))
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
      `((LANGUAGE
         (MATCHER-1 ANCHOR-1 OFFSET-1)
         (MATCHER-N ANCHOR-N OFFSET-N))

        ;; I-Rule: Assert if no rule matched and asserts are enabled.
        ,LANGUAGE-ts-mode--indent-assert-rule)
      "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock.
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent.
      ;; See: ./tests/test-LANGUAGE-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))
#+end_src

To write the indent rules, we need to define the /matcher/, /anchor/, and /offset/ of each rule as
explained in the Emacs manual, "[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-based Indentation]]".  The /matcher/ and /anchor/ are
functions that take three arguments, tree-sitter =node=, tree-sitter =parent= node, and =bol=.  The
=node= can be nil when not in a node. For example, when you type return, RET, after a statement.
=bol= is the beginning-of-line buffer position. /matcher/ returns non-nil when the rule applies and
/anchor/ returns the buffer position, which along with /offset/ determines the indent level of the
line.

Let's take this basic example of our LANGUAGE, =if_else.lang= file

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

Running =M-x treesit-explore-mode= gives us:

#+begin_example
  (source_file
   (if_statement if
    condition: (comparison_operator (identifier) > (number))
    \n
    (block
     (assignment left: (identifier) =
      right: (binary_operator left: (identifier) * right: (number)))
     ;)
    (else_clause else \n
     (block
      (assignment left: (identifier) = right: (identifier))
      ;))
    end)
   \n)
#+end_example

We start with

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

Notice that we are using =(rx bos "source_file" eos)= instead of just "source_file" for our regular
expression that is matched against the parent node.  If you use =M-x ielm= and type =(rx bos
"source_file" eos)=, you see this results in the compiled regular expression ="\\`source_file\\'"=
with the start of string and end of string specifiers. We could have typed that directly, but it is
better to use the =rx= notation because it can produce more optimal regular expressions when you
have more complex regular expressions.

If you look at the definition of parent-is, you'll see it leverages =string-match-p= to do the
matching against =(treesit-node-type parent-node)=.  Therefore, to be precise, we match using the
start of the string, =bos=, and end of string, =eos=.  If your nodes are unique enough, you can
leave off the =bos= and =eos=, but that could be troublesome if the grammar is updated. For example,
suppose you have a "function" node, and you match using =(parent-is "function")=, then the grammar is
updated to have regular "function" nodes and "function2" nodes where you want to different font for
"function2".  The =(parent-is "function")= will match both. Therefore, we recommend being precise
when matching which will also give a slight boost in performance.

We set

: M-: (setq treesit--indent-verbose t)

and then hit the =TAB= key on lines when vising our =if_else.lang= file:

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

If we type =TAB= on the if a > 1 we'll see

 : -->N:#<treesit-node if_statement in 1-48> P:#<treesit-node source_file in 1-49> BOL:1 GP:nil NPS:nil

This gives us our first rule, =((parent-is ,(rx bos "source_file" eos)) column-0 0)= is the rule for
the root node, which in our LANGUAGE is "source_file" and says to start on column 0.

If we type  =TAB= on the "b = a * 2" line in the following =if_else.lang= file.
we'll see in the =*Messages*= buffer we'll see in the =*Messages*= buffer:

 : -->N:#<treesit-node block in 14-24> P:#<treesit-node if_statement in 1-48> BOL:14 GP:#<treesit-node source_file in 1-49> NPS:#<treesit-node "

where point 14-24 is "b = a * 2" and we see it has a node named "block". Thus, we update we add to
our indent rules, =((node-is ,(rx bos "block" eos)) parent 4)= and a couple more rules as shown
below. Notice we included a comment before each rule, which will aid in the long-term maintenance of
the code. If the font-lock rules are complex, you may also want to add ";; F-Rule: description"
comments to them.  I like using a common prefix in the comments to make the standout and searchable.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_source_file.lang
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_block.lang
       ((node-is ,(rx bos "block" eos)) parent 4)
       ;; I-Rule: <TAB> else
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_else.lang
       ((node-is ,(rx bos "else_clause" eos)) parent 0)
       ;; I-Rule: <TAB> end
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_end.lang
       ((node-is ,(rx bos "end" eos)) parent 0)
       ;; I-Rule: Assert if no rule hit
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

*Tip*: =C-M-x= in our =defvar= and re-run =M-x LANGUAGE-ts-mode= file to pick up the new indent
rules.

*Tip*: If you look at the definition, =M-x find-variable RET treesit-simple-indent-presets RET=, you
can see how the built-in /matchers/ and /anchors/ are written. From that, you can write your own as
needed.

We can simplify this because the "else_clause" and "end" nodes have the same indent rules
so we can combine them and also handle nested if-statements as shown below.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_source_file.lang
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_block.lang
       ((node-is ,(rx bos "block" eos)) parent 4)
       ;; I-Rule: <TAB> if condition
       ;;         <TAB> else
       ;;         <TAB> end
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_else.lang
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_end.lang
       ((node-is ,(rx bos (or "if_statement" "else_clause" "end") eos)) parent 0)

       ;; I-Rule: Assert if no rule matched and asserts are enabled.
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

Following this process, we complete our indent engine by adding more rules. As we develop
the rules, it is good to lock down expected behavior with tests.

*** Setup: Indent Considerations

1. Indent rules may be easy to define using the treesit package pre-defined matchers and anchors
   when there are no syntax errors.

2. It is a good idea to ensure that indent work well when there are syntax errors thus giving
   a natural editing experience. Consider the case of typing in code, you want the RET to
   go to the right location on the next line, even when there is a syntax error. For example,

   : myStruct.field = someFcn(arg1, <RET>
   :                          ^                <== Point should be here

   The indent tests below help with this by programmatically typing "line-by-line" each test
   case to ensure the behavior is as expected when you are typing code.

3. You can use functions for matcher, anchor, and offset as in

   #+begin_src emacs-lisp
     (defvar LANGUAGE-ts-mode--indent-rules
       `((LANGUAGE
          ;; <snip>
          (,#'my-matcher-fun ,#'my-anchor-fun, ,#'my-offset-fun)
          ;; <snip>
          )))
   #+end_src

   Be careful with my-offset-fun. It should not base the offset on the point of the prev-node or
   anything like that. This is because =indent-region= does a batch indent to improve
   performance. It does not do line-by-line indenting. Therefore, the offset must not be based on
   the indentation of prior lines.

** Test: Indent

We use a looping pattern similar to the font-lock test for our indent tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-indent.el
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test1.lang
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test1_expected.lang       // generated for you
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test1_expected_msgs.lang  // generated for you
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test2.lang
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test2_expected.lang       // generated for you
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test2_expected_msgs.lang  // generated for you
  ....
#+end_example

where test-LANGUAGE-ts-mode-indent.el contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-indent--file nil)

  (defun test-LANGUAGE-ts-mode-indent--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-indent--file \"test-LANGUAGE-ts-mode-indent-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-indent--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-indent")))

  (ert-deftest test-LANGUAGE-ts-mode-indent ()
    "Test indent.
  Compare indent of ./test-LANGUAGE-ts-mode-indent-files/NAME.lang
  against ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang.
  Indent is done several ways as described in `t-utils-test-indent'.
  This loops on all ./test-LANGUAGE-ts-mode-indent-files/NAME.lang
  files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-indent-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang~
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected_msgs.lang~
  after validating them, rename them to
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected_msgs.lang"

    (let* ((test-name "test-LANGUAGE-ts-mode-indent")
           (lang-files (t-utils-get-files
                        test-name
                        (rx ".lang" eos)
                        nil
                        test-LANGUAGE-ts-mode-indent--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-indent test-name)))
#+end_src

This test,

1. Runs indent-region on NAME.lang and compares against NAME_expected.lang.
2. Indents the unindented contents of NAME.lang and compares against NAME_expected.lang.
3. Indents the contents of NAME.lang line-by-line, simulating typing code line-by-line.

** Test: Indent as you type

Code should be indented correctly as you type. Consider

 : someVariable = {
 :                  ^   <== Cursor should move here when RET is typed at end of prior line

To test this we use =t-utils-xr= to execute and record editing commands. The test setup:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-indent-xr.el
  ./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1.lang
  ./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1_expected.org  // generated for you
  ....
#+end_example

where =test-LANGUAGE-ts-mode-indent-xr.el= contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-indent-xr--file nil)

  (defun test-LANGUAGE-ts-mode-indent-xr--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-indent-xr--file
        \"test-LANGUAGE-ts-mode-indent-xr-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-indent-xr--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-indent-xr")))

  (ert-deftest test-LANGUAGE-ts-mode-indent-xr ()
    "Test indent using ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang.
  Using ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang, compare typing
  commands via `t-utils-xr' Lisp commands in the *.lang files and compare
  against ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org.  This
  loops on all ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org"

    (let* ((test-name "test-LANGUAGE-ts-mode-indent-xr")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-indent-xr--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-xr test-name lang-files)))
#+end_src

An example =./tests/test-matlab-ts-mode-indent-xr-files/indent_cell1.m= where =%= is starts a
comment and =%{ ... %}= is a block comment:

#+begin_src matlab-ts
  % -*- matlab-ts -*-

  %{
    TestLabel:
    (t-utils-xr

    (re-search-forward "%}")  "C-n"
    (insert "someVariable = {")      "C-m"
    (insert "1234")                  "C-m"
    (insert "};")                    "C-m"
    (re-search-backward "^someVariable")
    (t-utils-xr-print-code (point) (point-max))

    )
  %}
#+end_src

The execute and record function, =t-utils-xr= run the Emacs commands within it. In this example,
we are re-playing the actions of typing

#+begin_src matlab-ts
  someVariable = {
                   1234
                 };
#+end_src

Any standard Emacs commands are allowed, e.g. "C-m" for Enter/Return (RET). In addition, you can use
=(t-utils-xr-print-code START-POINT END-POINT)= to capture the result of running the commands in the
baseline.

You can interactively evaluate the =t-utils-xr= macro to debug the actions. Place the point
just after the closing parenthesis and type =C-x C-e= or =M-x eval-last-sexp= and each
command is run with a prompt showing what happened.

 : (t-tuils-xr ... )
 :                  ^   Put point here, and type C-x C-e to manually execute and record

The commands are executed and recorded. The recorded results are compared against baseline:

 : =./tests/test-matlab-ts-mode-indent-xr-files/indent_cell1_expected.org=

If the baseline doesn't exist or the result doesn't match the baseline, the test fails, and the
following tilde file is created:

 : =./tests/test-matlab-ts-mode-indent-xr-files/indent_cell1_expected.org~=

You can then rename the tilde file to =indent_cell1_expected.org= or fix the code as needed.

** Sweep test: Indent

We define a sweep test to be a test that tries an action on many files and reports issues it finds.
Sweep tests differ from classic baseline tests such as the above where we run functions and check
the result for correctness.  A sweep test of indent on many thousands of LANGUAGE files cannot check
the result of each individual indent because there is no baseline results for each file. However, a
sweep test can check for asserts, unexpected errors, and slow indents. It can also check for invalid
parse trees reported by the LANGUAGE tree-sitter if you have an external command that can check for
syntax errors in your LANGUAGE files.

Our indent sweep test takes a directory and runs indent-region all LANGUAGE files under the
directory recursively.

 - If the parse tree indicates an error, we call the external syntax checker to double check that
   the file does indeed have a syntax error. If the external checker says the file does not have a
   syntax error, we report the file, and this is likely a bug in the LANGUAGE tree-sitter parser.

 - If check-valid-parse below is t the test will call syntax checker on all files being processed to
   verify that there was a successful tree-sitter parse also that there are no errors according to
   syntax checker. Any inconsistent parses are reported which is likely a bug in the tree-sitter
   parser.

 - Next, =indent-region= is run on the file in a temporary buffer. The time it takes is recorded and
   the slowest indents are reported.  If you see slow indents, there could be bugs in your
   tree-sitter parser.

 - If =indent-region= generates errors, then they is also reported.  For example, suppose we write a
   lambda indent MATCHER that contains

    : (string-match-p my-node-regexp (treesit-node-type (treesit-node-prev-sibling parent))

   In our classic test things work fine because our test has a parent with a previous
   sibling. However, we may have missed that parent may not have a previous sibling. A sweep of many
   LANGUAGE files has a good probability of hitting this. If parent doesn't have a previous sibling,
   we'll get "error (void-function string-match-p)."

Our indent sweep test:

#+begin_src emacs-lisp
  (require 't-utils)

  (defun sweep-test-LANGUAGE-ts-mode-indent--syntax-checker (file)
    "Syntax check FILE, return pair (VALID . CHECK-RESULT).
  Where VALID is t if the file has valid syntax, nil otherwise.
  String CHECK-RESULT is what the syntax checker command returned."
    (let ((out (shell-command-to-string
                (concat (shell-quote-argument your-syntax-checker-command)
                        " "
                        (shell-quote-argument file))))
          valid)

      (setq valid
            (not
             (string-match-p
              (rx
               (or "error:"
  		 "fatal error:"))
              out)))
      (cons valid out)))

  (defun sweep-test-LANGUAGE-ts-mode-indent (&optional directory check-valid-parse)
    "Use `LANGUAGE-ts-mode' to indent each language file in DIRECTORY.

  If DIRECTORY isn't specified, it defaults to the current directory.

  CHECK-VALID-PARSE if t, will call SYNTAX-CHECKER-FUN on all files being
  processed to verify that the a successful tree-sitter parse also has no
  errors according to SYNTAX-CHECKER-FUN.  Any inconsistent parses are
  reported which is likely a bug in the tree-sitter parser.

  This calls `t-utils-sweep-test-indent' with does a number of
  checks to validate the ident rules.  When run interactively,
  displays the result in a *t-utils-seep-indent* buffer, otherwise
  the results are displayed on stdout."

    (let ((test-name "sweep-test-LANGUAGE-ts-mode-indent")
          (LANGUAGE-ts-mode--indent-assert t))

      (t-utils-sweep-test-indent
       test-name
       (or directory default-directory)
       (rx ".lang" eos) ;; our language files
       #'LANGUAGE-ts-mode
       :syntax-checker-fun #'sweep-test-LANGUAGE-ts-mode-indent--syntax-checker
       :check-valid-parse check-valid-parse)))
#+end_src

We can run our sweep test via

 : C-x C-f RET /path/to/directory/root/containing/language/files RET
 : M-: (sweep-test-LANGUAGE-ts-mode-indent)
 : M-: (sweep-test-LANGUAGE-ts-mode-indent nil t)  ;; more checking but slower

* Setup: Syntax Table

The Emacs "syntax table" is not related to the syntax tree created by tree-sitter. A syntax tree
represents the hierarchical structure of your source code, giving a structural blueprint of your
code.

Think of the syntax table as a "language character descriptor". The syntax table defines the
syntactic role of each character within the buffer containing your source code.  Characters are
assigned a syntax class which includes word characters, comment start, comment end, string
delimiters, opening and closing delimiters (e.g.  =(=, =)=, =[=, =]=, ={=, =}=), etc. The syntax
table enables natural code editing and navigating capabilities. For example, the syntax table is
used by movement commands, e.g. =C-M-f", =M-x forward-sexp=, based on syntactic expressions (words,
symbols, or balanced expressions). The syntax table is used for parentheses matching. It enables
comment operations such as =M-;=, =M-x comment-dwim=.

Below is our minimal LANGUAGE-ts-mode.el with the syntax table and comment support added. Note, our
single-line comments are of form "% comment" and block comments are of form "%{ <lines> %}". This is
set up by using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Descriptors.html][Emacs Syntax Descriptors]]. This may seem a bit obscure, but it's very elegant for
comments that start or end with one or two characters. If you have more complex syntax needs, for
example you'd like to allow "// single-line comments" but not for URL's http://location you'll need
to =(setq-local syntax-propertize-function (syntax-properties-rules ("./\\(/+\\)" (1 "."))))=.  If
you have more complex needs you'll need to set syntax-propertize-function to a function that calls
=(put-text-property start-point end-point 'category CATEGORY)=.

Notice that in our =LANGUAGE-ts-mode= definition, we set up the syntax table and comments first.
This is good practice because these are fundamental to Emacs.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  ;;-----------------------;;
  ;; Section: Syntax table ;;
  ;;-----------------------;;

  (defvar LANGUAGE-ts-mode--syntax-table
    (let ((st (make-syntax-table (standard-syntax-table))))
      ;; Comment Handling:
      ;; 1. Single line comments: % text (single char start),
      ;;                          note includes "%{ text"
      ;; 2. Multiline comments:   %{
      ;;                            lines
      ;;                          %}
      (modify-syntax-entry ?%  "< 13"  st)
      (modify-syntax-entry ?{  "(} 2c" st)
      (modify-syntax-entry ?}  "){ 4c" st)
      (modify-syntax-entry ?\n ">"     st)

      ;; String Handling:
      ;;   Single quoted string: 'text'
      ;;   Double-quoted string: "text"
      (modify-syntax-entry ?'  "\"" st)
      (modify-syntax-entry ?\" "\"" st)

      ;; Words and Symbols include the underscore
      (modify-syntax-entry ?_  "_" st)

      ;; Punctuation:
      (modify-syntax-entry ?\\ "." st)
      (modify-syntax-entry ?\t " " st)
      (modify-syntax-entry ?+  "." st)
      (modify-syntax-entry ?-  "." st)
      (modify-syntax-entry ?*  "." st)
      (modify-syntax-entry ?/  "." st)
      (modify-syntax-entry ?=  "." st)
      (modify-syntax-entry ?<  "." st)
      (modify-syntax-entry ?>  "." st)
      (modify-syntax-entry ?&  "." st)
      (modify-syntax-entry ?|  "." st)

      ;; Parenthetical blocks:
      ;;   Note: these are in standard syntax table, repeated here for completeness.
      (modify-syntax-entry ?\(  "()" st)
      (modify-syntax-entry ?\)  ")(" st)
      (modify-syntax-entry ?\[  "(]" st)
      (modify-syntax-entry ?\]  ")[" st)
      (modify-syntax-entry ?{   "(}" st)
      (modify-syntax-entry ?}   "){" st)

      st)
    "The LANGUAGE-ts-mode syntax table.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Syntax-table
      ;; See: ./tests/test-LANGUAGE-ts-mode-syntax-table.el
      (set-syntax-table LANGUAGE-ts-mode--syntax-table)

      ;; Comments
      (setq-local comment-start      "%")
      (setq-local comment-end        "")
      (setq-local comment-start-skip "%\\s-+")

      ;; Font-lock
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent
      ;; See: ./tests/test-LANGUAGE-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))
#+end_src

** Test: Syntax Table

We use a looping pattern similar to the font-lock test for our syntax table tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-syntax-table.el
  ./tests/test-LANGUAGE-ts-mode-syntax-table-files/syntax_table_test1.lang
  ./tests/test-LANGUAGE-ts-mode-syntax-table-files/syntax_table_test1_expected.lang  // generated for you
#+end_example

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-syntax-table--file nil)

  (defun test-LANGUAGE-ts-mode-syntax-table--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-syntax-table--file \"test-LANGUAGE-ts-mode-syntax-table-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-syntax-table--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-syntax-table")))

  (ert-deftest test-LANGUAGE-ts-mode-syntax-table ()
    "Test syntax-table using ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang.
  Compare ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.txt, where
  NAME_expected.txt gives the `syntax-ppss' value of each character in
  NAME.lang.  This loops on all ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang
  files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang"

    (let* ((test-name "test-LANGUAGE-ts-mode-syntax-table")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-syntax-table--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-syntax-table test-name lang-files)))
#+end_src

* Setup: treesit-thing-settings

Examining treesit-major-mode-setup,

 : M-: (find-function 'treesit-major-mode-setup)

we see that with Emacs 30, there are three items to setup:

 : 'defun
 : 'sexp
 : 'sentence
 : 'text

='defun= is used by end-of-defun via end-of-defun-function set to treesit-end-of-defun. You should
setup ='defun= instead of treesit-defun-type-regexp for a consistent setup where all things for
navigation, etc. are all controlled by treesit-thing-settings.  If you do set
treesit-defun-type-regexp it overrides ='defun= for compatibility. The defun movement commands
you should test after setting up ='defun=:

#+begin_example
  C-M-a  Move to beginning of defun, beginning-of-defun
  C-M-e  Move to end of defun, end-of-defun
  C-M-h  Marks defun, place point at beginning of defun and mark at the end, mark-defun
#+end_example

For proper syntactic expression movement, you should define ='sexp=. Defining 'sexp requires that you
also define ='text= to cover comments and strings. ='sexp= and ='text= are used by forward-sexp and
friends (forward-sexp-function is set treesit-forward-sexp by treesit-major-mode-setup).

Syntactic expressions, s-expressions, or simply sexp commands operate on /balanced
expressions/. Strings are naturally balanced expressions because they start and end with some type
of quote character. Likewise brackets =[ items ]= and braces ={ items }= are typically balanced
expressions because they have open and close characters. Some languages have keywords expressions
that have a starting keyword and an ending keyword. For example, "if" could be paired with a closing
"end" keyword. s-expressions can span multiple lines. s-expressions can be nested. These commands
leverage ='sexp= and ='text= things:

#+begin_example
  C-M-f   Move forward by s-expression, forward-sexp
          - If point is on the start of an s-expression, move to the end.
          - If point is on the end of an s-expression, move to the start of the next s-expression
            at the same level. If there is no next s-expression, no movement occurs.
  C-M-b   Move backward by s-expression, backward-sexp
          - If point is on the end of an s-expression, move to the start.
          - If point is on the start of an s-expression, move to the start of the prior s-expression
            at the same level. If there is no prior s-expression, no movement occurs.
  C-M-SPC Mark s-expression, place point at beginning of sexp and mark at the end, mark-sexp
  C-M-@   Same as C-M-SPC.
  C-M-k   Kill s-expression, kill-sexp
  C-M-t   Transpose s-expressions, transpose-sexp
#+end_example

='sentence= and ='text= are used by forward-sentence via forward-sentence-function which is set to
treesit-forward-sentence. The following sentence movement commands use forward-sentence:

#+begin_example
  M-e      Move forward to next end of sentence, forward-sentence
  M-a      Move backward to start of sentence, backward-sentence
  M-k      Kill from point to end of sentence, kill-sentence
  C-x DEL  Kill back from point to start of sentence, backward-kill-sentence
#+end_example

You can add other items to treesit-thing-settings such as ='comment= and ='string=, though
treesit.el doesn't currently use these, so I'd avoid doing so because the names you choose may not
match future items treesit.el will use.

The following commands move via parenthesis, though they are not tree-sitter aware. For example, it
would be nice if down-list / up-list could be redirected to move up and down the nested
s-expressions, but you cannot do that. Similar for forward-list, backward-list.

#+begin_example
  C-M-d   Move down into a list, down-list
  C-M-u   Move up out of a list, up-list
  C-M-n   Move forward to the next list expression in the same level, forward-list
  C-M-p   Move backward to the previous list expression in the same level, backward-list
#+end_example

** Setup: configure forward-sexp-function after treesit-major-mode-setup

It is likely that the treesit-forward-sexp won't do the right thing in comments or with parenthesis,
brackets, and braces, so for these we should just use =forward-sexp-default-function= for those.
To do this, we define

#+begin_src emacs-lisp
(defun LANGUAGE-ts-mode--forward-sexp (&optional arg)
  "Use `treesit-forward-sexp' when matching code only.
ARG is described in the docstring of `forward-sexp'.  When we are
matching a parenthesis, bracket, brace, or when point is in a comment do
the normal s-expression movement by calling
`forward-sexp-default-function'."
  (interactive "^p")
  (let* ((move-back (and (numberp arg) (< arg 0)))
         (match-paren (if move-back
                          (member (char-before) '(?\] ?\) ?\}))
                        (member (char-after) '(?\[ ?\( ?\{)))))
    (if (or match-paren
            (let* ((pt-and-node (LANGUAGE-ts-mode--real-node-at-point))
                   (node (cdr pt-and-node)))
              (equal (treesit-node-type node) "comment")))
        ;; See tests/test-LANGUAGE-ts-mode-thing-settings-files/thing_forward_sexp1.lang
        (forward-sexp-default-function arg)
      (treesit-forward-sexp arg))))
#+end_src

and then re-set =forward-sexp-function= after =(treesit-major-mode-setup)=:

#+begin_src emacs-lisp
  (when (treesit-ready-p 'matlab)
    (treesit-parser-create 'matlab)

    ;; <snip>

    (treesit-major-mode-setup)

    ;; Correct forward-sexp setup created by `treesit-major-mode' so that for parenthesis, brackets,
    ;; braces, and comments we do normal s-expression matching using parenthesis.
    (setq-local forward-sexp-function #'LANGUAGE-ts-mode--forward-sexp)
    ))
#+end_src

** Test: treesit-thing-settings

To add tests, we follow similar pattern to our other tests above and leverage
=t-utils-test-xr=.

* Setup: Fill Paragraph, M-q

=M-q= is bound to =prog-fill-reindent-defun= from =prog-mode=, which when the point is in a comment
will fill the comment. If the point is in code it will indent the code. If the point is in a string,
M-q will fill the string like it's plain text, which can result in syntax errors. This is expected
behavior because one can then fix the syntax behaviors by adding appropriate string
continuations. There's no way to alter the string filling behavior besides using defadvice, which
you should not do.

If your syntax table correctly identifies comments and strings, then =M-q= just works, though you
should still add tests to validate it works.  If you'd like tree-sitter nodes other than comments
and strings to be filled like plain text, you should add a =text= entry to =treesit-thing-settings=,
e.g. if nodeName1 and nodeName2 should be filled like plain text, use:

 #+begin_src emacs-lisp
 (defvar LANGUAGE-ts-mode--thing-settings
  `((LANGUAGE
     (text ,(rx (or "nodeName1" "nodeName2" ....))))))
 #+end_src

and in defun of LANGUAGE-ts-mode, add =(setq-local treesit-thing-settings
LANGUAGE-ts-mode--thing-settings)= after you've setup your syntax table.

** Test: Fill Paragraph

We use =t-utils-xr= and a looping test to look over all
=./tests/test-LANGUAGE-ts-mode-fill-paragraph-files/fill_paragraph_test*.lang= files:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-fill-paragraph.el
  ./tests/test-LANGUAGE-ts-mode-fill-paragraph-files/fill_paragraph_test1.lang
  ./tests/test-LANGUAGE-ts-mode-fill-paragraph-files/fill_paragraph_test1_expected.org
  ./tests/test-LANGUAGE-ts-mode-fill-paragraph-files/fill_paragraph_test2.lang
  ./tests/test-LANGUAGE-ts-mode-fill-paragraph-files/fill_paragraph_test2_expected.org
  ....
#+end_example

An example =fill_paragraph_test1.lang= where '%' starts a comment:

#+begin_src matlab
  % -*- matlab-ts -*-
  function b = fill_paragraph_test1(a)

      % Setup test to use a small fill column
      % (t-utils-xr (set-fill-column 60))
      %
      % Test of fill paragraph
      % (t-utils-xr "C-n" "C-n" "M-q")
      %
      % A very long comment. A very long comment. A very long comment. A very long comment. A very long comment.

      b = 1;
  end
#+end_src

and the corresponding baseline, =fill_paragraph_test1_expected.org=

#+begin_src org
  ,#+startup: showall

  ,* Executing commands from fill_paragraph_test1.m:5:6:

    (t-utils-xr (set-fill-column 60))

  - Invoking      : (set-fill-column 60)
    Start point   :  142
    No point movement
    No buffer modifications

  ,* Executing commands from fill_paragraph_test1.m:8:6:

    (t-utils-xr "C-n" "C-n" "M-q")

  - Invoking      : "C-n" = next-line
    Start point   :  214
    Moved to point:  220
    : 9:5:     %
    :           ^
    No buffer modifications

  - Invoking      : "C-n" = next-line
    Start point   :  220
    Moved to point:  226
    : 10:5:     % A very long comment. A very long comment. A very long comment. A very long comment. A very long comment.
    :            ^
    No buffer modifications

  - Invoking      : "M-q" = prog-fill-reindent-defun
    Start point   :  226
    No point movement
    Buffer modified:
    ,#+begin_src diff
  --- start_contents
  +++ end_contents
  @@ -7,7 +7,8 @@
       % Test of fill paragraph
       % (t-utils-xr "C-n" "C-n" "M-q")
       %
  -    % A very long comment. A very long comment. A very long comment. A very long comment. A very long comment.
  +    % A very long comment. A very long comment. A very long
  +    % comment. A very long comment. A very long comment.

       b = 1;
   end
    ,#+end_src diff

#+end_src

The =test-LANGUAGE-ts-mode-fill-paragraph.el=:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-fill-paragraph--file nil)

  (defun test-LANGUAGE-ts-mode-fill-paragraph--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-fill-paragraph--file
         \"test-LANGUAGE-ts-mode-fill-paragraph-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-fill-paragraph--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-fill-paragraph")))

  (ert-deftest test-LANGUAGE-ts-mode-fill-paragraph ()
    "Test fill paragraph.
  Using ./test-LANGUAGE-ts-mode-fill-paragraph-files/NAME.lang, run
  `fill-paragraph' and compare result against
  ./test-LANGUAGE-ts-mode-fill-paragraph-files/NAME_expected.org.  This loops
  on all ./test-LANGUAGE-ts-mode-comments-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-fill-paragraph-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-fill-paragraph-files/NAME_expected.org~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-fill-paragraph-files/NAME_expected.org"

    (let* ((test-name "test-LANGUAGE-ts-mode-fill-paragraph")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-fill-paragraph--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-xr test-name lang-files)))
#+end_src


* Setup: treesit-defun-name-function

Emacs supports the concept of Change Logs for documenting changes.  With version control systems
like git, there's less need for Change Logs, though the format of the Change Logs.  In Emacs using
=C-x 4 a= (add-change-log-entry-other-window) will end up calling =add-log-current-defun= which
defers to the =treesit-defun-name-function= to get information for the entry to add to the log file.

#+begin_src emacs-lisp
(defun LANGUAGE-ts-mode--defun-name (node)
  "Return the defun name of NODE for Change Log entries."
  (when (string-match-p
         (rx bos (or "function_definition" "class_definition") eos)
         (treesit-node-type node))
    (treesit-node-text (treesit-node-child-by-field-name node "name"))))

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    ;; xxx
    (setq-local treesit-defun-name-function #'LANGUAGE-ts-mode--defun-name)
    ;; xxx
    )
#+end_src

** Test: treesit-defun-name-function

To add tests, we follow similar pattern to our other tests above and leverage
=t-utils-test-treesit-defun-name=.

* Setup: IMenu

Emacs =M-g i= (=M-x imenu=), makes it easy to jump to items in your file. If our mode populates
imenu with the location of the function definitions, we can quickly jump to them by name. You can
also leverage [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Which-Function.html][M-x which-function-mode]] to have Emacs display the imenu entry for the current point in
the mode line. You can view imenu in a sidebar window, using, [[https://github.com/oantolin/embark][embark]], [[https://github.com/rnkn/side-hustle][side-hustle]], or [[https://github.com/bmag/imenu-list][imenu-list.]]

To populate imenu, in LANGUAGE-ts-mode, we setup =treesit-simple-imenu-settings=, where each element
is of form =(category regexp pred name-fn)=, but form many languages, you only need to specify the
first two elements.  When name-fcn is nil the imenu names are generated by the
=treesit-defun-name-function= which we already set up.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--imenu-settings
    `(("Class" ,(rx bos "class_definition" eos))
      ("Function" ,(rx bos "function_definition" eos)))
    "Tree-sitter imenu settings.")

  ;; <snip>

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    ;; <snip>
    (setq-local treesit-defun-name-function #LANGUAGE-ts-mode--defun-name)
    (setq-local treesit-simple-imenu-settings LANGUAGE-ts-mode--imenu-settings)
    ;; <snip>
    )
#+end_src

Alternatively, for complex languages, you can =(setq-local imenu-create-index-function
#'LANGUAGE-ts-mode--imenu-create-index)= and within =LANGUAGE-ts-imenu-create-index=, walk the
tree-sitter parse tree and generate the index.

** Test: IMenu

We leverage =t-utils-test-imenu-create-index-function= from t-utils.el to create tests similar to
the above test patterns.

* Setup: Outline, treesit-outline-predicate

This needs to be set up if =treesit-simple-imenu-settings= has not been set and you are using a
custom =imenu-create-index-function= as we did above.

#+begin_src emacs-lisp
  (defun LANGUAGE-ts-mode--outline-predicate (node)
    "Outline headings for `outline-minor-mode' with LANGUAGE.
  Returns t if tree-sitter NODE defines an outline heading."
    (let ((node-type (treesit-node-type node)))
      (or (string-match-p (rx bos (or "function_definition" "class_definition") eos) node-type)
          (and (string= "comment" node-type)
               (save-excursion
                 (goto-char (treesit-node-start node))
                 (beginning-of-line)
                 (looking-at LANGUAGE-ts-mode--comment-heading-re t))))))
#+end_src

and

#+begin_src emacs-lisp
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    ;; <snip>
    (setq-local treesit-outline-predicate #'LANGUAGE-ts-mode--outline-predicate)
    ;; <snip>
    )
#+end_src

** Test: Outline

To add tests, we follow a similar pattern to our other tests above and leverage
=t-utils-test-outline-search-function=.

* Setup: Electric Pair, electric-pair-mode

=M-x electric-pair-mode= for most languages will just work. However, if your language
uses typical characters that are paired, e.g. a single quote for a string delimiter and
also an operator such as a transpose, then you'll need to:

#+begin_src emacs-lisp
  (declare-function electric-pair-default-inhibit "elec-pair")
  (defun LANGUAGE-ts-mode--electric-pair-inhibit-predicate (char)
    "Return non-nil if `electric-pair-mode' should not pair this CHAR.
  Do not pair the transpose operator, (\\='), but pair it when used as a
  single quote string."

    ;; (point) is just after CHAR. For example, if we type a single quote:
    ;;   x = '
    ;;        ^--(point)

    (cond
     ;; Case: Single quote
     ((eq char ?')
      ;; Look at the tree-sitter nodes and return t if the pairing should be inhibited.
      ;; <snip>
      )

     ;; Case: Not a single quote, defer to the standard electric pair handling
     (t
      (funcall #'electric-pair-default-inhibit char))))

  ;; <snip>
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"

    ;; <snip>

    ;; Electric pair mode
    (setq-local electric-pair-inhibit-predicate #'LANGUAGE-ts-mode--electric-pair-inhibit-predicate)
    )
#+end_src

** Test: Electric Pair

To add tests, we follow similar pattern to our other tests above and leverage
=t-utils-test-xr=.

* Setup: show-paren-mode

show-paren-mode uses =show-paren-data-function= to match "start" with "end" pairs. For example:

 : myfcn(1, 2, 3)                  x = {1, 2, 3, 4}
 :      ^       ^                      ^          ^
 :    here     there                  here       there

Your programming language may have other items that should be paired. You can leverage
show-paren-mode as a general "show pair mode". For example, you can extend show-paren-mode
to show matching start/end quotes in a string:

 : s = "foo bar"
 :     ^       ^
 :    here    there

If your programming language has block-like keywords, we can pair them. For example:

 :  if condition
 :  ^
 :      myfcn(1, 2, 3)
 :  end
 :  ^

To extend show-paren-mode, we set =show-paren-data-function= for our mode. Below we illustrate
how to do string matching assuming strings can be created using ='single quotes'= or
="double quotes"= where the string tree sitter nodes are:

  : (string " (string_content) ")
  : (string ' (string_content) ')

#+begin_src emacs-lisp
  (declare-function show-paren--default "paren")

  (defun LANGUAGE-ts-mode--show-paren-or-block ()
    "Function to assign to `show-paren-data-function'.
  Highlight LANGUAGE pairs in addition to standard items paired by
  `show-paren-mode'.  Returns a list: \\='(HERE-BEGIN HERE-END THERE-BEGIN
  THERE-END MISMATCH) or nil."
    (let* (here-begin
           here-end
           there-begin
           there-end
           mismatch
           (pt (point))
           (node (treesit-node-at pt)))

      ;; If point is in whitespace, (treesit-node-at (point)) returns the nearest node. For
      ;; paired matching we want the point on either a start or end paired item.
      (let ((node-start (treesit-node-start node))
            (node-end (treesit-node-end node)))
        (when (and (>= pt node-start)
                   (<= pt node-end))
          (let* ((node-type (treesit-node-type node))
                 (parent-node (treesit-node-parent node))
                 (parent-type (treesit-node-type parent-node)))

            (cond

             ;; Case: on a single or double quote for a string.
             ((and (or (equal "'" node-type)
                       (equal "\"" node-type))
                   (equal "string" parent-type))
              (let (q-start-node
                    q-end-node)
                (if (= (treesit-node-start parent-node) (treesit-node-start node))
                    ;; looking at start quote
                    (setq q-start-node node
                          q-end-node parent-node)
                  ;; else looking at end quote
                  (setq q-start-node parent-node
                        q-end-node node))

                (setq here-begin (treesit-node-start q-start-node))
                (setq here-end (1+ here-begin))

                (let* ((candidate-there-end (treesit-node-end q-end-node))
                       (candidate-there-begin (1- candidate-there-end)))
                  (cond
                   ;; Case: Have starting quote of a string, but no content or closing quote.
                   ((= here-begin candidate-there-begin)
                    (setq mismatch t))
                   ;; Case: Have starting quote, have string content, but no closing quote
                   ((not (equal (char-after here-begin) (char-after candidate-there-begin)))
                    (setq mismatch t))
                   (t
                    (setq there-begin candidate-there-begin)
                    (setq there-end candidate-there-end))))))

             ;; Add cases for other pairs.
             ;; Note set mismatch to t if we have say a start keyword of a pair
             ;; but are missing the end keyword.

             ))))

      (if (or here-begin here-end)
          (list here-begin here-end there-begin there-end mismatch)
       (funcall #'show-paren--default))))

    (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
      "Major mode for editing LANGUAGE files with tree-sitter."
      ;; <snip>
      (setq-local show-paren-data-function #'LANGUAGE-ts-mode--show-paren-or-block)
    )
#+end_src

** Test: show-paren-mode

Test file structure:

 : LANGUAGE-ts-mode.el
 : tests/test-LANGUAGE-ts-mode-show-paren.el
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM1.LANG
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM1_expected.org
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM2.LANG
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM2_expected.org
 : ...

where =tests/test-LANGUAGE-ts-mode-show-paren.el= contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-show-paren--file nil)

  (defun test-LANGUAGE-ts-mode-show-paren--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-show-paren--file \"test-LANGUAGE-ts-mode-show-paren-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-show-paren--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-show-paren")))

  (ert-deftest test-LANGUAGE-ts-mode-show-paren ()
    "Test show paren mode using ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang.
  Using ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang, result of
  `LANGUAGE-ts-mode--show-paren-or-block' for `show-paren-mode' against
  ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org.  If LANG-FILE is
  not provided, loop comparing all
  ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org"

    (let* ((test-name "test-LANGUAGE-ts-mode-show-paren")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-show-paren--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-xr test-name lang-files)))
#+end_src

Each =tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM.LANG= file looks like the
following assuming we have =% comment=" lines, replace with your language comments.

#+begin_example

  // -*- LANGUAGE-ts -*-

    <snip - code to define string variables>

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s1 = '<foo '' bar>';

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s2 = '<foo '' bar>';

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s3 = "<foo ' bar>";

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s4 = "<foo ' bar>";

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s5 = "<asdf

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s6 = asdf>"

    <snip>

#+end_example

The tests are using the execute and record function, =t-utils-xr= which runs commands and records
them into a =*.org= file. We run the test and if
=tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM_expected.org= doesn't exist,
=tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM_expected.org~= will be generated and
after inspection rename the =*.org~= to =*.org=.

For example, the last t-utils-xr result in the *.org file is below. Notice, that standard-output is
"(910 911 nil nil t)" which indicates we have here-begin and here-end, but no there-begin and no
there-end with mismatch true (t) because the string is missing the starting quote.

#+begin_src org
  ,* Executing commands from show_paren_string.lang:25:2:

    (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))

  - Invoking      : (re-search-forward ">")
    Start point   :  899
    Moved to point:  910
    : 26:10: s6 = asdf>"
    :                  ^
    No buffer modifications

  - Invoking      : (prin1 (LANGUAGE-ts-mode--show-paren-or-block))
    Start point   :  910
    No point movement
    standard-output:
      (910 911 nil nil t)
    No buffer modifications
#+end_src

* Setup: Handling Corrupted Content

Corrupted content in LANGUAGE, NAME.LANG, files can crash Emacs when your tree-sitter
language shared library runs on the corrupted content.  For example, try load a large
binary file and =M-x LANGUAGE-major-mode=.  Since content should be utf-8, you should add
to the start of your LANGUAGE-major-mode:

#+begin_src emacs-lisp
  (defun LANGUAGE-ts-mode--check-file-encoding ()
    "Check file encoding.
  Error is signaled if contents are corrupt because non-utf8 printable
  content can crash Emacs via the LANGUAGE tree-sitter parser."

    (let ((bad-char-point (save-excursion
                            (goto-char (point-min))
                            (when (re-search-forward "[^[:print:][:space:]]" nil t)
                              (point)))))
      (when bad-char-point
        (fundamental-mode)
        (goto-char bad-char-point)
        (user-error "Buffer appears corrupt, non-printable utf8 character at point %d: %c"
                    bad-char-point (char-before)))))


  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Documentation."

    (LANGUAGE-ts-mode--check-file-encoding)

    (when (treesit-ready-p 'LANGUAGE)
      ;; <snip>
      ))
#+end_src

** Test: Handling Corrupted Content

Test setup:

 #+begin_example
 ./LANGUAGE-ts-mode.el
 ./tests/test-LANGUAGE-ts-mode-file-encoding.el
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME1.LANG
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME1_expected.txt
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME2.LANG
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME2_expected.txt
 ....
 #+end_example

=./tests/test-LANGUAGE-ts-mode-file-encoding.el= contains:

  #+begin_src emacs-lisp
    (require 't-utils)
    (require 'LANGUAGE-ts-mode)

    (defvar test-LANGUAGE-ts-mode-file-encoding--file nil)

    (defun test-LANGUAGE-ts-mode-file-encoding--file (lang-file)
      "Test file-encoding on LANG-FILE."
      (let ((test-LANGUAGE-ts-mode-file-encoding--file lang-file))
        (ert-run-tests-interactively "test-LANGUAGE-ts-mode-file-encoding")))

    (ert-deftest test-LANGUAGE-ts-mode-file-encoding ()
      (let* ((test-name "test-LANGUAGE-ts-mode-file-encoding")
             (lang-files (t-utils-get-files
                       test-name
                       (rx ".lang" eos)
                       nil
                       test-LANGUAGE-ts-mode-file-encoding--file)))
        (t-utils-error-if-no-treesit-for \\='LANGUAGE test-name)
        (t-utils-test-file-encoding test-name lang-files \\='#LANGUAGE-ts-mode)))
  #+end_src

Create /tests/test-LANGUAGE-ts-mode-file-encoding-files/*.LANG files containing corrupted
(non-utf-8) content. Also create at least one valid *.LANG files.

Run the test:

 : M-x ert RET test-LANGUAGE-ts-mode-file-encoding RET

In the =ert= result buffer, you can type \"m\" at the point of the test (where
the color marker is) to see messages that were displayed by your test.

If the =./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME*_expected.txt~= files look good
rename them to =./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME*_expected.txt= (per the
messages shown by ert).

* Setup: keymap and menu

We inherited from prog-mode which gives us a keymap. If our language has
additional commands we'd like to bind to key, we do it =defvar-keymap=.
To add a menu, we do it using =easy-menu-define=.

#+begin_src emacs-lisp
  (defvar-keymap LANGUAGE-ts-mode-map
    :doc "Keymap for `LANGUAGE-ts-mode' buffers."
    :parent prog-mode-map

    "KEYS-1" 'language-command-1
    "KEYS-2" 'language-command-2
    ;; <snip>
    )

  (easy-menu-define LANGUAGE-mode-menu LANGUAGE-ts-mode-map
    "Menu for `LANGUAGE-ts-mode'."

    '("LANGUAGE"
      ["Command 1" language-command-1
       :help "help for command 1"]
      ["Command 2" language-command-2
       :help "help for command 2"]))

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
     ;;; <snip>
    )
#+end_src

* Final version

The above steps were used to create matlab-ts-mode.el, which you can look at to see our final
version and learn from it.

* Summary

Tree-sitter powered modes provide highly accurate syntax coloring, indentation, and other features.
In addition, tree-sitter modes are generally much more performant than the older-style regular
expression-based modes, especially for a reasonably complex programming language.

A downside of a tree-sitter mode is that the necessary =libtree-sitter-LANGUAGE.SLIB= shared library
files are not provided with the =NAME-ts-mode='s that are shipped with Emacs. For =NAME-ts-mode='s
that are installed via =M-x package-install LANGUAGE-ts-mode=, the corresponding
=libtree-sitter-LANGUAGE.SLIB= shared libraries are not installed.  You can have Emacs build
=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB= via =M-x treesit-install-language-grammar=, but
this can result in shared libraries that do not run correctly because of a compiler version mismatch
between what was used for Emacs and what was used to build =libtree-sitter-LANGUAGE.SLIB=.

Another problem with =M-x treesit-install-language-grammar= is that it doesn't specify the
application binary interface (ABI) version when building. For example, Emacs 30.1 is at ABI 14
=(treesit-library-abi-version)=, and tree-sitter is at 15 and if you attempt to use what
=M-x treesit-install-language-grammar= creates, you'll see:

 : Warning (treesit): The installed language grammar for LANGUAGE cannot be located or has problems (version-mismatch): 15

Ideally, =M-x treesit-install-language-grammar= would be updated to do more error checking to
ensure the right compilers are in place and specify the ABI version. Something like:

 : tree-sitter generate --abi 14
 : gcc src/*.c -I./src -o ~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.so --shared -fPIC -Os

As of Jun-2025, for Emacs 30, you can copy the prebuilt shared library, LANGUAGE.SLIB, from
https://github.com/emacs-tree-sitter/tree-sitter-langs and place it in
=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=. Note, Emacs will first look for
=libtree-sitter-LANGUAGE.SLIB= in =treesit-extra-load-path=, then in subdirectory =tree-sitter= under
=user-emacs-directory= (=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=), then in the system
=/lib=.

These downsides are relatively minor compared with the benefits of a tree-sitter powered mode. It is
well worth writing a tree-sitter mode.

* Building matlab tree sitter manually

On Debian 12 Intel/AMD 64-bit, install node and gcc if not installed:

#+begin_src bash
  sudo apt update
  sudo apt install nodejs npm
  node --version
  # v18.19.0

  sudo apt install gcc
  gcc --version
  # gcc (Debian 12.2.0-14+deb12u1) 12.2.0

#+end_src

Download and extract tree-sitter-linux-x64.gz from
https://github.com/tree-sitter/tree-sitter/releases into some location, e.g.

 : ~/emacs-projects/tree-sitter-bin/tree-sitter

Get matlab tree-sitter, e.g.

#+begin_src bash
  cd ~/emacs-projects
  git clone https://github.com/acristoffers/tree-sitter-matlab.git
#+end_src

Build:

#+begin_src bash
  cd ~/emacs-projects/tree-sitter-matlab
  ~/emacs-projects/tree-sitter-bin/tree-sitter generate --abi 14
#+end_src

Install, using default branch

#+begin_example
  emacs
  M-x treesit-install-language-grammar
  Language: matlab
  There is no recipe for matlab, do you want to build it interactively? (y or n) y
  Enter the URL of the Git repository of the language grammar: ~/emacs-projects/tree-sitter-matlab
  Enter the tag or branch (default: default branch):
  Enter the subdirectory in which the parser.c file resides (default: "src"):
  Enter the C compiler to use (default: auto-detect):
  Enter the C++ compiler to use (default: auto-detect):
  Install to (default: ~/.emacs.d/tree-sitter):
#+end_example

* Issues

** prev-line for treesit-simple-indent-rules

  In [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-Based Indentation]] we have prev-line which goes backward exactly one line

  Consider a programming language with a few statements, e.g.

  #+begin_example
    {
        a = 1;
        b = 2;


    }
  #+end_example

  If you use prev-line on the blank-line immediately after "b = 2;", you'll get the expected point
  below "b". If you use prev-line on the second blank line after "b = 2;", the point move the
  first blank line after the "b = 2;" statement which may not be what you want. Perhaps prev-real
  should look backwards to the first prior line with non-whitespace. If there's concern about
  compatibility, treesit could be updated to have:

  #+begin_src emacs-lisp
    (cons 'prev-real-line (lambda (_n _p bol &rest _)
    			(save-excursion
    			  (goto-char bol)
    			  (forward-line -1)
    			  (while (and (not (bobp))
    				      (looking-at "^[ \t]*$"))
    			    (forward-line -1))
    			  (skip-chars-forward " \t")
    			  (point))))
  #+end_src

  and document that prev-line doesn't go to the previous line.

** Building libtree-sitter-matlab.dll from src on Windows produces a DLL that fails.

- Install Emacs from https://www.gnu.org/software/emacs/download.html
- Install MSYS2
- Run MSYS2 bash, then: =pacman -S gcc= (installs gcc 13)
- Install gpg from https://www.gpg4win.org/ and place it on the path before MSYS2.
  The version of gpg in MSYS2 is not compatible with Emacs package-install.
- Install tree sitter from src using Emacs 30.1

Example:

#+begin_example
  emacs
  M-x treesit-install-language-grammar
  Language: matlab
  There is no recipe for matlab, do you want to build it interactively? (y or n) y
  Enter the URL of the Git repository of the language grammar: https://github.com/acristoffers/tree-sitter-matlab
  Enter the tag or branch (default: default branch): abi/14
  Enter the subdirectory in which the parser.c file resides (default: "src"):
  Enter the C compiler to use (default: auto-detect):
  Enter the C++ compiler to use (default: auto-detect):
  Install to (default: ~/.emacs.d/tree-sitter):
#+end_example

Note the build of the dll from https://github.com/emacs-tree-sitter/tree-sitter-langs is good.
Perhaps, Visual Studio is needed, and =M-x treesit-install-language-grammar= should look for
that?

** =M-x treesit-install-language-grammar= doesn't check the ABI version.

Emacs 30 is using tree-sitter ABI version 14 is behind the current tree-sitter ABI version, 15.
It would be nice if =M-x treesit-install-language-grammar= detected that there was a conflict
by looking at the #define in the source. It could offer to re-build the src from the repository
for the ABI needed. For example:

 : cd /path/to/grammar-work-tree-root
 : /path/to/tree-sitter generate --abi 14

If tree-sitter isn't found, it should offer to download it.

** M-q (prog-fill-reindent-defun) splits strings

When the point is in a string and you type M-q it will split long strings into multiple lies which
results in syntax errors in some languages. It would be nice to either fix this or have an option
that instructs M-q to indent or fill comments, but never split strings. When in a string it
should do nothing if it can't guarantee the syntax will be correct. Ideally, we'd have a way to fill
strings by using the appropriate string concatenation characters.

** Doc for treesit-thing-settings is misleading.

It mentions a "comment" thing, but that is not used by treesit. Also looking at the
setting for C/C++, what's written

  : ((c
  :   (defun "function_definition")
  :   (sexp (not "[](),[{}]"))
  :   (comment "comment")
  :   (string "raw_string_literal")
  :   (text (or comment string)))
  :  (cpp
  :   (defun ("function_definition" . cpp-ts-mode-defun-valid-p))
  :   (defclass "class_specifier")
  :   (comment "comment")))

doesn't match the source.

** Major Mode Conventions, kill-all-local-variables confusion

In https://www.gnu.org/software/emacs/manual/html_node/elisp/Major-Mode-Conventions.html, we have

 - Major Mode Conventions:

   + The major mode command should start by calling kill-all-local-variables. This runs the normal
     hook change-major-mode-hook, then gets rid of the buffer-local variables of the major mode
     previously in effect. See Creating and Deleting Buffer-Local Bindings.

However, existing Emacs 30 modes like c-ts-mode do not call this?

# LocalWords:  showall usepackage parskip tocloft cftsecnumwidth cftsubsecindent cftsubsecnumwidth
# LocalWords:  lang utils Imenu LSP defun ELPA tuils setq SLIB libtree dylib sexp xr defcusom MLint
# LocalWords:  defface EDebug ielm fontify Fontifying fontified defcustom alist eos bol NPS prev BUF
# LocalWords:  caar cdar bos dwim propertize ppss SPC reindent defadvice IMenu imenu pred fn elec
# LocalWords:  funcall myfcn prin asdf repeat:nil ABI abi MSYS pacman gpg bobp defclass docstring
# LocalWords:  fontification lsp numberp cdr keymap sudo nodejs npm linux gz builtins flycheck
