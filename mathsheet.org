* goal
the goal is to generate a math practice sheet.

similar to https://www.math-aids.com
* script
** vars
#+property: header-args+ :var student="Noble" problem-count=26

** problem sets
*** add and subtract

#+name: firstset
| weight | order | problem                       | descr                  |
|--------+-------+-------------------------------+------------------------|
|      3 |     1 | [1..10] + [0..10]             | simple                 |
|      2 |     2 | [1..10] + [8..15]             | second number bigger   |
|      1 |     2 | [a=3..10] - [0..$a]           | subtraction            |
|      1 |     3 | [1..10] + [1..7] + [1..5]     | three numbers          |
|      1 |     4 | [a=1..10] + [0..10] - [0..$a] | three with subtraction |
|      0 |     0 | [$a*[1..5]] / [a=1..10]       | division               |

** problem generation

TODO create a package. if you C-c C-c on a table
1. if you are on the header, generate a worksheet
2. if you on on a row, generate a single example

*** var-list
need ~var-list~ to keep track of the variables between fields.

#+name: var-list
#+begin_src elisp
(defvar ianxm/var-list '()
"List of variables used in a problem")
#+end_src
*** scan field

must call with point at the start of a field. moves the point to the
end of the field. returns a list of fields, formatted as:

#+begin_example
'(var (deps) start-marker end-marker nil)
#+end_example

~var~ is a variable name if there is an assignment, or it is a
placeholder like ~_0~, ~_1~, etc. the last entry is nil for "not
visited." ~var~ must be interned and must be the first index since we
use this as an alist.

~start-marker~ and ~end-marker~ are markers in the (temp) buffer.

for example:
#+begin_example
[$a + 2 + [a=1..5]] => '((nil (a) m1 m19 nil) (a nil m11 m18 nil))
#+end_example

~open-fields~ is a stack of fields with the current field on top. we
push a new field to the stack when we start a new field.
~closed-fields~ is a list of fields that have been completed. we push a
new field to the list when we close the current field.

#+name: scan-problem
#+begin_src elisp
  (defun ianxm/scan-problem ()
    (interactive)
    (let ((field-index 0)
          open-fields ; stack (open close (vars) deps)
          closed-fields) ; list (open close (vars) deps)

      (with-peg-rules
          ((stuff (* (or var letter digit symbol field space)))
           (field open (opt assignment) stuff close)
           (space (* [space]))
           (open (region "[")
                 `(l r -- (progn
                            (setq
                             open-fields (push (list
                                                (intern (concat "_" (number-to-string field-index)))
                                                nil (copy-marker l) nil nil)
                                               open-fields)
                             field-index (1+ field-index))
                            ".")))
           (assignment (region (substring letter)) "="
                       `(l v r -- (progn
                                    (setcar
                                     (car open-fields)
                                     (intern v))
                                    ".")))
           (var "$" (substring letter)
                `(v -- (progn
                         (setcar
                          (nthcdr 1 (car open-fields))
                          (push (intern v) (nth 1 (car open-fields))))
                         ".")))
           (close (region "]")
                  `(l r -- (progn
                             (setcar (nthcdr 3 (car open-fields)) (copy-marker l t))
                             (when (> (length open-fields) 1)
                               (setcar
                                (nthcdr 1 (nth 1 open-fields))
                                (push (caar open-fields) (nth 1 (nth 1 open-fields)))))
                             (setq
                              closed-fields
                              (push (pop open-fields) closed-fields))
                             ".")))
           (letter [a-z])
           (digit [0-9])
           (symbol (or "." "+" "-" "*" "/" "(" ")")))

        (peg-run (peg stuff)
                 (lambda (x) (message "failed %s" x))
                 (lambda (x)
                   (funcall x)
                   closed-fields)))))
#+end_src

*** reduce field

must call with point at the start of a field. moves point to the end
of the field. returns a list containing the value to which the field
reduces.

#+name: reduce-field
#+begin_src elisp
    (defun ianxm/reduce-field ()
      (interactive)
      (with-peg-rules
          ((field "[" space (or range sequence assignment expression value) space "]")
           (expression (list value space operation space value (* space operation space value))
                       `(vals -- (string-to-number
                                  (calc-eval
                                   (mapconcat
                                    (lambda (x) (if (numberp x) (number-to-string x) x))
                                    vals
                                    " ")))))
           (operation (substring (or "+" "-" "*" "/")))
           (assignment var-lhs space "=" space (or range sequence)
                       `(v r -- (progn
                                  (setq var-list (push (cons (intern v) r) var-list))
                                  r)))
           (range value ".." value
                  `(min max -- (+ (random (- max min)) min)))
           (sequence (list value "," value (* "," value))
                     `(vals -- (seq-random-elt vals)))
           (value (or (substring (opt "-") (+ digit)) var-rhs parenthetical)
                  `(v -- (if (stringp v) (string-to-number v) v)))
           (parenthetical "(" expression ")"
                          (action (message "paren")))
           (var-lhs (substring letter)) ; var for assignment
           (var-rhs "$" (substring letter) ; var for use
                    `(v -- (let ((val (alist-get (intern v) var-list)))
                             (or val (error "var %s not set" v)))))
           (space (* [space]))
           (letter [a-z])
           (digit [0-9]))

        (peg-run (peg field)
                 (lambda (x) (message "failed %s" x))
                 (lambda (x) (funcall x)))))
#+end_src

*** replace field

replace a field with the value returned from processing it.

#+name: replace-field
#+begin_src elisp
  (defun ianxm/replace-field (node)
    (let ((start (nth 2 node))
          (end (1+ (nth 3 node)))
          val)
      (goto-char start)
      (when (looking-at "\\[")
        (setq val (car (ianxm/reduce-field)))
        (goto-char start)
        (delete-char (- end start) t)
        (insert (number-to-string val)))))
#+end_src

*** dfs visit

check dependencies then visit the node

#+name: dfs-visit
#+begin_src elisp
  (defun ianxm/dfs-visit (node fields)
    (pcase (nth 4 node)
      (1 (error "cycle detected")) ; cycle
      (2)                          ; skip
      (_                           ; process
       (setcar (nthcdr 4 node) 1)  ; started
       (let ((deps (nth 1 node)))
         (dolist (dep deps)
           (ianxm/dfs-visit
            (assq dep fields)
            fields)))
       (ianxm/replace-field node) ; visit
       (setcar (nthcdr 4 node) 2)))) ; mark done
#+end_src
*** fill fields in problem

processes all fields in a problem.

#+begin_example
(full-problem (buffer-substring (point-at-bol) (point-at-eol)))
#+end_example

#+name: fill-problem
#+begin_src elisp :var full-problem="[$a + 2 + [a=1..5]]"
  (defun ianxm/fill-problem (full-problem)
      (interactive)
      (let (fields)
        (with-temp-buffer
          ;; stage problem in temp buffer
          (insert full-problem)
          (beginning-of-buffer)

          ;; find fields, assignments, dependencies
          (setq fields (ianxm/scan-problem))
          ;;(message "fields %s" fields)

          ;; order fields according to dependencies
          (dolist (node fields)
            (ianxm/dfs-visit node fields))
          (setq var-list '())
          (buffer-string))))
#+end_src

test with this
#+begin_src elisp :noweb yes
  <<full>>

  ;;(ianxm/fill-problem "[1..12] + [1..10]")
  ;;(ianxm/fill-problem "[1..[2..[10..100]]]")
  ;;(ianxm/fill-problem "[$a*[1..10]] / [a=1..10]")
  ;;(ianxm/fill-problem "[$a]/(3+[a=1..5])")
  (ianxm/fill-problem "[-10..[10..20]]")

#+end_src

#+RESULTS:
: -7

other examples
#+begin_example
  simple range
  [10..11]

  complex range
  [-10..[10..20]]

  complex with assignment
  [a=1..[2..8]]

  complex with inner assignment
  [-10..[b=10..20]]

  simple with variable
  [0..[$a..$b]]
#+end_example

*** full script
tangles everything needed to convert a template to a problem

#+name: full
#+begin_src elisp :noweb yes :tangle mathsheet.el
  <<var-list>>

  <<scan-problem>>

  <<reduce-field>>

  <<catalog-fields>>

  <<replace-field>>

  <<dfs-visit>>

  <<fill-problem>>

  <<generate-problems>>
#+end_src
** generate problem set from templates

1. load table
2. determine how many of each
   1. sort by weight, low to high
   2. for each row
      1. calculate number, round with min 1, but 0->0
   3. for last entry (highest weight) just take however many are left.
   4. produce '(order template nil) for each problem
   5. convert to '(order problem answer)
3. sort
4. loop through list, replacing entry with '(problem . solution)

#+name: generate-problems
#+begin_src elisp :results table :var templates=firstset
  (defun ianxm/generate-problems ()
    (let (total-weight problems)
      ;; sort by weight (low to high)
      (setq templates (sort templates (lambda (a b) (< (car a) (car b))))
            ;; calc total weight
            total-weight (float
                          (seq-reduce (lambda (total item) (+ total (car item)))
                                      templates
                                      0)))
      ;; calculate number for each row
      (dotimes (ii (length templates) problems)
        (let* (problem answer
                       (item (nth ii templates))
                       (weight (car item))
                       (needed (cond
                                ((= weight 0)
                                 0)
                                ((= ii (1- (length templates)))
                                 (- problem-count (length problems)))
                                (t
                                 (max (round (* (/ weight total-weight) problem-count) ) 1)))))
          ;; add problems to list
          (dotimes (jj needed)
            (let* ((problem (ianxm/fill-problem (nth 2 item)))
                   (answer (calc-eval problem))
                   (order (nth 1 item)))
              (setq problems (push (list order problem answer) problems))))))

      ;; shuffle
      (dotimes (ii (- (length problems) 1))
        (let ((jj (+ (random (- (length problems) ii)) ii)))
          (psetf (elt problems ii) (elt problems jj)
                 (elt problems jj) (elt problems ii))))

      ;; sort by order
      (sort problems (lambda (a b) (< (car a) (car b))))

      ;; remove the "order" column and return
      (mapcar (lambda (x) (seq-drop x 1)) problems)))
#+end_src

test with this

#+name: problem-set
#+begin_src elisp :results table :noweb yes :var templates=firstset
  <<full>>

  (ianxm/generate-problems)
#+end_src

#+RESULTS: problem-set
| 9 + 9     | 18 |
| 1 + 4     |  5 |
| 8 + 2     | 10 |
| 3 + 7     | 10 |
| 6 + 4     | 10 |
| 1 + 1     |  2 |
| 7 + 4     | 11 |
| 5 + 5     | 10 |
| 4 + 1     |  5 |
| 9 + 13    | 22 |
| 2 + 14    | 16 |
| 4 + 10    | 14 |
| 9 + 11    | 20 |
| 4 + 12    | 16 |
| 3 + 12    | 15 |
| 3 + 4 + 3 | 10 |
| 2 + 6 + 1 |  9 |
| 7 + 5 + 1 | 13 |
| 8 - 7     |  1 |
| 8 + 1 - 3 |  6 |
| 4 - 0     |  4 |
| 6 + 3 - 3 |  6 |
| 3 - 0     |  3 |
| 8 + 7 - 5 | 10 |

** lay out problems and answers
this generates a problem set.

#+name: layout-problems-answers
#+begin_src elisp :results silent :noweb yes :var problem-set=problem-set problemsp='t
      (with-temp-buffer
          (dolist (row problem-set)
            (if problemsp
                (insert (format"\\CircledItem %s = \\rule[-.2\\baselineskip]{2cm}{0.4pt}\n\n"
                               (car row)))
              (insert (format "\\CircledItem %s\n\n"
                              (cadr row)))))
        (buffer-string))
#+end_src

** lay out page
this wraps the problems with a tex header and footer.

solution for how to enumerate with circled numbers from [[https://latex.org/forum/viewtopic.php?p=40006&sid=d202f756313add2391c3140fbeafe2ff#p40006][here]]

#+name: page
#+begin_src latex :results value silent :noweb yes
  \documentclass[12pt]{article}
  \usepackage[top=1in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
  \usepackage{fancyhdr}
  \newsavebox{\myheadbox}% Heading storage box
  \usepackage{multicol}
  \usepackage{rotating}
  \usepackage{xcolor}
  \usepackage{enumitem}
  \usepackage{tikz}
  \newcommand*\circled[1]{%
    \tikz[baseline=(C.base)]\node[draw,circle,inner sep=1.2pt,line width=0.2mm,](C) {#1};}
  \newcommand*\CircledItem{%
    \stepcounter{enumi}\item[\circled{\theenumi}]}

  \pagestyle{fancy}
  \lhead{\textmd{\textsf{Name: student}}}
  \rhead{\textmd{\textsf{Date: \today}}}
  \cfoot{}

  \renewcommand{\familydefault}{\ttdefault}

  \begin{document}

    \begin{multicols}{2}
      \begin{enumerate}[itemsep=0.5cm]
        <<layout-problems-answers(problemsp='t)>>
      \end{enumerate}
    \end{multicols}

    \vspace*{0.1cm}
    \noindent\rule{\linewidth}{0.4pt}
    \vspace*{0.1cm}

    \begin{turn}{180}
      \begin{minipage}{\linewidth}
        \color{gray}
        \footnotesize
        \begin{multicols}{4}
          \begin{enumerate}
            <<layout-problems-answers(problemsp='nil)>>
          \end{enumerate}
        \end{multicols}
      \end{minipage}
    \end{turn}

  \end{document}
#+end_src

* generate pdf
this writes the generated into a local file and runs ~texi2pdf~ to
convert it to a pdf.

#+begin_src elisp :results silent :var tex-content=page
  (with-temp-file "worksheet.tex"
    (insert tex-content))
  (shell-command "texi2pdf worksheet.tex"
                 (get-buffer-create "*Standard output*"))))
#+end_src
