# File: contributing/treesit-mode-how-to.org

# | Copyright 2025 Free Software Foundation, Inc.
# |
# | This program is free software: you can redistribute it and/or modify
# | it under the terms of the GNU General Public License as published by
# | the Free Software Foundation, either version 3 of the License, or
# | (at your option) any later version.
# |
# | This program is distributed in the hope that it will be useful,
# | but WITHOUT ANY WARRANTY; without even the implied warranty of
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# | GNU General Public License for more details.
# |
# | You should have received a copy of the GNU General Public License
# | along with this program.  If not, see <http://www.gnu.org/licenses/>.
# |
# | Commentary:
# |   Guidelines for writing a major mode powered by tree-sitter

#+startup: showall

#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles-from-org.css"/>
#+html_head_extra: <link rel="stylesheet" type="text/css" href="css/styles.css"/>
#+options: ^:{}
#+options: toc:nil
#+latex_header: \usepackage[margin=0.5in]{geometry}
#+latex_header: \usepackage{parskip}
#+latex_header: \usepackage{tocloft}
#+latex_header: \advance\cftsecnumwidth 0.5em\relax
#+latex_header: \advance\cftsubsecindent 0.5em\relax
#+latex_header: \advance\cftsubsecnumwidth 0.5em\relax

#+title: How to Create and Test an Emacs Tree-Sitter Major Mode
#+author: John Ciolfi
#+date: Jun-30-2025

* TODO

- [ ] Clean up flow of doc.
- [ ] Clean up the testing. This is a work in progress and needs many fixes.
- [ ] Add sweep test for indent
      - (directory-files-recursively DIR "\\.m$")
      - On each file, check parse tree for ERROR nodes and see if it really has an error by running
        matlab/bin/arch/mlint and looking for "Parse error". If no parse error, then flag these as
        issues with the matlab tree-sitter.
      - Indent the file to see if matlab-ts-mode--indent-assert-rule fires
- [ ] Add test for comment handling
- [ ] Investigate [[https://www.gnu.org/software/emacs/manual/html_mono/ert.html][ERT]] and [[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]] testing
- [ ] When done
  + validate we replaced: matlab => LANGUAGE, .m => .lang, m-file => lang-file
  + double check our t-utils.el programmatically insert it
  + programmatically insert all tests?

* What does tree-sitter provide?

Tree-sitter provides a parse tree for your language in real-time. The tree-sitter parser for your
language is a highly efficient C shared library that is loaded into the Emacs process. The parse
tree is incrementally updated as you type, and errors are localized to the smallest nodes in the
tree. This means you can build a very accurate and highly performant major mode for your language
leveraging tree-sitter for:

 - Syntax highlighting.
 - Indenting as you type. This includes accurate indentation when there are syntax errors.
 - Semantic navigation. For example, go-to function start, go-to function end, etc.
 - Imenu for navigation to function definitions or other items in your buffer.
 - Highlight of paired items, such as parentheses, brackets, braces, function start/end, quotes,
   etc.
 - Electric pair mode to automatically insert matching closing delimiters such as parentheses,
   brackets, braces, quotes, etc.

Tree-sitter differs from the Language Server Protocol, LSP. They both parse the source file but
have different objectives. LSP is a separate process and thus is not incremental, so much slower. It
does a deeper analysis of the source file. For example, with languages like C/C++, LSP parses the
include headers so it can provide go-to definition, find references, diagnostics warning and error
messages, and similar capabilities. These LSP capabilities are not provided by tree-sitter, nor
does it make sense for tree-sitter to provide them. It makes perfect sense that Emacs provides
both tree-sitter and LSP because they both provide complementary capabilities for coding.

* Guide to building a tree-sitter mode

This guide to building a *LANGUAGE-ts-mode* for /file.lang/ files was written using Emacs 30.1.

In creating a tree-sitter mode for a programming language, you have two options. You can leverage an
old-style existing mode via =(define-derived-mode LANGUAGE-ts-mode OLD-LANGUAGE-mode "LANGUAGE"
...)= and then override items such as font-lock and indent. The other approach is to create a new
LANGUAGE-ts-mode based on prog-mode which we recommend to eliminate coupling between the old-style
mode and the new tree-sitter mode.

#+begin_src emacs-lisp
 (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE" ...)
#+end_src

To create the mode, we recommend following this order:

1. *Font-lock*. Do this first, so that /file.lang/ is syntactically colored when viewing it.
2. *Indent*. Next set up indentation so that you can edit /file.lang/ easily.
3. *Syntax table and comments*.
4. *Imenu*
5. *Navigation*. Set up treesit-defun-type-regexp and treesit-defun-name-function to enable
   navigation features like beginning-of-defun and end-of-defun
6. *Others*. In the sections below, you will see additional items to polish off your tree-sitter major mode.

Writing tests as you develop your =LANGUAGE-ts-mode= will speed up the creation of the
mode and payoff nicely when making future updates to the mode. Test infrastructure is provided
which is designed to be used by your =LANGUAGE-ts-mode=. Avoid developing the full fledged mode,
then adding tests because if you are like the rest of us, you'll keep putting off writing the tests
which will make =LANGUAGE-ts=mode= very difficult to maintain.

Emacs has the testing frameworks, [[https://www.gnu.org/software/emacs/manual/html_node/ert/index.html][ERT, Emacs Lisp Regressing Testing.]] There is also the [[https://github.com/jorgenschaefer/emacs-buttercup/][Emacs
buttercup]] though this is non-ELPA. To make creation and testing of the major mode easy, fast, and
efficient, I built t-tuils.el that leverages ERT and adds looping capabilities, baseline file
generation, and execute-and-record capabilities. With these extra capabilities, it is very fast to
author high-coverage tests. For example, when writing a font-lock test, you provide the =file.lang=
and run the test. The test will see there is no expected baseline to compare against, so it will
generate one for you and ask you to validate it. The expect baseline for =file.lang= is
=file_expected.txt= and the contents of the =file_expected.txt= is of same length of =file.lang=,
where each character's face is encoded in a single character. This makes it very easy to lock down
the behavior of font-lock without having to write lisp code to add the expected rsults of the
test. The same test strategy is used for other aspects of our =LANGUAGE-ts-mode=.

* Major Mode Conventions

Start by reading [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Major-Mode-Conventions.html][Emacs Major Mode Conventions]], with the following exceptions:

- Do not use kill-all-local-variables because the *-ts-mode.el shipped with Emacs do not use that.
- Do not set major-mode to 'LANGUAGE-ts-mode, this is set by =(treesit-parser-create 'LANGUAGE)=
- Do not setup indent-line-function, we'll do that using treesit
- Do not set font-lock-defaults, we'll do that using treesit
- Do not use make-local-variable, instead use setq-local
- Do not setup a mode hook, this is done for you

* Syntax trees and queries

If you are not familiar with the concepts behind tree-sitter, see
https://tree-sitter.github.io/tree-sitter. Learn the notion of queries and try out queries in the
playground section of the site on one of the languages supported by the site. A good understanding
of the syntax tree and queries are required to implement a new tree-sitter major mode. You don't
need to understand how to implement a language parser if one already exists, otherwise you'll need
to write a tree-sitter language parser.

The tree-sitter parser produces a syntax tree:

#+begin_example
  +-------+     +------------------------------+   shared library,
  |       |     |                              |   SLIB = .so    on Linux
  | Emacs |<===>| libtree-sitter-LANGUAGE.SLIB |          .dll   on Windows
  |       |     |                              |          .dylib on Mac
  +-------+     +------------------------------+
#+end_example

The libtree-sitter-LANGUAGE.SLIB shared library is used to create a syntax tree of LANGUAGE:

#+begin_example
  LANGUAGE program             Syntax Tree

   c = a + b                      =
                                /   \
                               c     +
                                   a   b
#+end_example

Each node in the syntax tree knows it start point and end point in the LANGUAGE program. The
parser is fast and incrementally updates as you type. The memory required to represent the syntax
tree is roughly 10 times the text size of the program being analyzed. However, the benefits of
tree sitter are highly accurate and fast syntax coloring (font-lock), indentation, code
navigation via syntactic expressions, etc.

* Documentation

 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html][Emacs manual: Parsing Program Source]]
 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Emacs manual: Parser-based Indentation]]
 - [[https://archive.casouri.cc/note/2024/emacs-30-tree-sitter/][Notes: Tree-sitter Changes in Emacs 30]]

* libtree-sitter-LANGUAGE.SLIB

Place the tree-sitter language library in =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=
(EXT=.so on Linux, .dll on Windows, .dylib on Mac). There are other locations that this can
reside in, though =~/.emacs.d/tree-sitter/= is the default.

- You can grab the LANGUAGE.SLIB from https://github.com/emacs-tree-sitter/tree-sitter-langs/releases
  and rename it to =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=.

- You can build it using

  : M-x treesit-install-language-grammar

It is possible that =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB= was built incorrectly,
so we create the following to validate it, replacing LANGUAGE with your language name.

Next, create a basic LANGUAGE-ts-mode.el to validate your tree-sitter shared library is good.  If
your libtree-sitter-LANGUAGE.SLIB was built incorrectly (e.g. wrong compiler version), the following
will likely hang.

#+begin_src emacs-lisp
  ;; Basic LANGUAGE-ts-mode.el

  (require 'treesit)

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files with tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)
      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)

#+end_src

Validate your LANGUAGE-ts-mode works. Create foo.lang (where .lang is the extension used by your
language) containing valid LANGUAGE content, then open foo.txt in Emacs and run:

: M-x LANGUAGE-ts-mode

You should now be able to use:

: M-x treesit-inspect-mode
: M-x treesit-explore-mode

* Debugging tips

- Incremental updates to your LANGUAGE-ts-mode

   As you update =LANGUAGE-ts-mode.el= you need to tell Emacs to pick up the updates. To do this,

    - Use =C-x C-e=. With the cursor =(point)= at the end of the syntactic expression in your
      file and run =C-x C-e= (or =M-x eval-last-sexp=) to evaluate the sexp prior to the cursor
      point. The =C-x C-e= binding is very helpful with the =(t-utils-xr ....)= macros
      you place in your NAME.LANG test files.

    - Use =C-M-x= (or =M-x eval-defun=). With the =(point)= in the
      =defun=, =defvar=, =defcusom=, =defface=, etc. run =C-M-x= to evaluate it.

    - Use =C-u C-M-x= within a =defun= to EDebug it.

   Note: =M-x eval-buffer= will not reevaluate already defined =defvar='s (and other items), so you
   must use one of the above to update a =defvar=, etc.

- =M-x LANGUAGE-ts-mode=

 - After making updates to =LANGUAGE-ts-mode.el= and evaluating them, you run =M-x LANGUAGE-ts-mode=
   to re-load your mode in your =test.lang= file. For example, when writing the indent rules, you'll
   need to run =M-x LANGUAGE-ts-mode= after =M=x eval-defun= on in your =(defvar
   LANGUAGE-ts-mode--indent-rules ....)=.

- Use =M-x ielm=

  In the =*ielm*= buffer created by =M-x ielm=, you can examine tree-sitter nodes, etc. For example:

  #+begin_example
  ELISP> (with-current-buffer "test.lang"
           (treesit-node-parent (treesit-node-at (point))))
  #+end_example

* Setup: Font-lock

Queries are needed to identify syntax tree nodes to semantically color language elements
(font-lock). See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-Matching.html][Emacs manual - Pattern Matching Tree-sitter Nodes]]. You can use =M-x
treesit-explore-mode= to see the nodes of the syntax tree.

An example of a query that identifies comments, assuming =comment= is the node type for comments,
in a file that has =M-x LANGUAGE-ts-mode= active.

: M-: (treesit-query-capture (treesit-buffer-root-node) '((comment) @comments))

Suppose your language contains the keyword "if", you can find all "if" keywords using:

: M-: (treesit-query-capture (treesit-buffer-root-node) '("if" @keywords))

To capture all keywords of your language, use alternation. Here we are capturing the "if"
and "else" keywords:

: M-: (treesit-query-capture (treesit-buffer-root-node) '(["if" "else"] @keywords))

Note, to validate your queries use:

: M-x (treesit-query-validate 'LANGUAGE '(QUERY @capture-name))

Once we know the queries, we can set up font-lock. For example, here we fontify comments, keywords,
and within comments we highlight to do markers.

As you are developing your font-lock rules, you should enable

 : M-: (setq treesit--font-lock-verbose t)

This will display messages of the following form which can be helpful in debugging.

 : Fontifying text from START-POINT to END-POINT, Face: FACE, Node: TYPE

Another debugging tip, is to use the =%S= format specifier in calls to message which displays the
lisp object representation.  For example, in our defun LANGUAGE-ts-mode--comment-to-do-capture, we
could add =(message "debug comment-node: %S" comment-node)= which will show what it's processing.
Using EDebug on font-lock functions can be tricky because they get called on display updates.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  (defvar LANGUAGE-ts-mode--keywords
    '("else"
      "if"
      "end"
      ;; <snip>
      )
    "The LANGUAGE-ts-mode font-lock keywords.")

  (defun LANGUAGE-ts-mode--comment-to-do-capture (comment-node override start end &rest _)
    "Fontify comment to do, fix me, and triple-x markers.
  COMMENT-NODE is the tree-sitter comment node from a
  treesit-font-lock-rules rule and OVERRIDE is from that rule.  START and
  END specify the region to be fontified which could be smaller or larger
  than the COMMENT-NODE start-point and end-point."
    (save-excursion
      (let ((comment-end (treesit-node-end comment-node)))
        (goto-char (treesit-node-start comment-node))
        (while (< (point) comment-end)
          ;; Note, the markers below have spaces in them so we don't find them when searching "C-s"
          ;; while editing this file.
          (if (re-search-forward (rx word-start (group (or (seq "to" "do")
                                                           (seq "fix" "me")
                                                           (seq "x" "xx")))
                                     word-end)
                                 comment-end t)
              (let ((keyword-start (match-beginning 1))
                    (keyword-end (match-end 1)))
                (treesit-fontify-with-override keyword-start keyword-end
                                               'LANGUAGE-ts-mode-comment-to-do-marker-face
                                               override start end))
            (goto-char comment-end))))))

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules

     ;; F-Rule: Comments and line continuation: ... optional text
     ;; See: tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_comments.lang
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     ;; F-Rule: to do, fix me, triple-x marker comment keywords
     ;; See: test-LANGUAGE-ts-mode-font-lock-files/font_lock_comment_markers.lang
     :language 'matlab
     :feature 'comment-marker
     :override t
     '(((comment) @LANGUAGE-ts-mode--comment-to-do-capture))

     ;; F-Rule: keywords: if, else, etc.
     ;; See: tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_keywords.lang
     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face))
    "The LANGUAGE tree-sitter font-lock settings.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock.
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
                                                   (keyword string type)
                                                   (number bracket delimiter)
                                                   (syntax-error)))

      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)
  ;;; LANGUAGE-ts-mode.el ends here
#+end_src

Notice how the =@capture-name= in the comment query is =@font-lock-comment-face=. This face is
applied to the items captured by the query. You can see available faces by using =M-x
list-faces-display=.  You'll probably want to stick with faces that come with stock Emacs to avoid
dependencies on other packages or create your own face.

Within =LANGUAGE-ts-mode--font-lock-settings= we added comments of for ";; F-Rule: description"
which include a reference to a test.  You may wish to consider adding these comments. It will help
others when trying to understand what rules do and make your code more maintainable. We use
a unique string to start the comments, so they are searchable.

The =treesit-font-lock-feature-list= contains four sublists where the first sublist is font-lock
level 1, and so on. Each sublist contains a set of feature; names that correspond to the =:feature
'NAME= entries in =LANGUAGE-ts-mode--font-lock-settings=.  For example, ='comment= for comments,
='definition= for function and other definitions, ='keyword= for language keywords, etc. Font-lock
applies the faces defined in each sublist up to and including `treesit-font-lock-level', which
defaults to 3. If you'd like to have your font-lock default to level 4, add:

#+begin_src emacs-lisp
  (defcustom LANGUAGE-ts-mode-font-lock-level 3
    "*Level of font lock, 1 for minimal syntax highlighting and 4 for maximum."
    ;; Setting to 4 to results in parse errors causing too much "red". See 'syntax-error
    ;; font-lock feature below.
    :type '(choice (const :tag "Minimal" 1)
  		 (const :tag "Low" 2)
  		 (const :tag "Standard" 3)
  		 (const :tag "Standard plus parse errors" 4)))

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"

    ;; <snip>
    (setq-local treesit-font-lock-level LANGUAGE-ts-font-lock-level)
    (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
    ;; <snip>
    )
#+end_src

** Test: Font-lock

It is recommended that you create tests to validate your font-lock set up and commit your tests with
your code together. This will make it easier for you and others to update your code without causing
regressions. Under our LANGUAGE-ts-mode.el, we create a tests subdirectory containing our tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/t-utils.el                                                // see "Appendix: t-utils.el"
  ./tests/test-LANGUAGE-ts-mode-font-lock.el
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang
  ./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt // generated for you
#+end_example

Where =tests/test-LANGUAGE-ts-mode-font-lock.el= is shown below. Notice that there's a
=code-to-face= table that assigns a character "code" to each face we are using. You may need to
update this table to meet your needs.

To add tests, create files of form
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1.lang= and then

 : M-x ert
 : Run tests: test-LANGUAGE-ts-mode-font-lock

This will create =./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt~= and
after examining it, rename it to
=./tests/test-LANGUAGE-ts-mode-font-lock-files/font_lock_test1_expected.txt=.

When you run ert interactively, you'll be presented with a =*ert*= buffer. You can
type "m" on the colored dots in the =*ert*= buffer to see the messages for that ert test
and the messages contain the sub-tests from the test loop for that ert test.  This will bring
up an =*ERT Messages*= buffer.  In this buffer, type
  : M-x compilation-minor-mode
to view the and navigate errors.  The default error viewing in the =*ert*= buffer is a bit dense
due to the looping nature of the t-utils tests.

To run your tests in a build system, use

#+begin_src bash
  emacs --batch -Q -l t-utils -eval t-utils-run
#+end_src

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'language-ts-mode)

  (defvar test-LANGUAGE-ts-mode-font-lock--file nil)

  (defun test-LANGUAGE-ts-mode-font-lock--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-font-lock--file \"test-LANGUAGE-ts-mode-font-lock-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-font-lock--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-font-lock")))

  (ert-deftest test-LANGUAGE-ts-mode-font-lock ()
    "Test font-lock using ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang.
  Compare font of ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt, where
  NAME_expected.txt is of same length as NAME.lang where each source
  character in NAME.lang is replaced with a character code representing the
  font-lock face used for said source character.  The mapping is defined
  by the code-to-face alist setup by this function.  This loops
  on all ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-font-lock-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-font-lock-files/NAME_expected.txt"

    (let* ((test-name "test-LANGUAGE-ts-mode-font-lock")
           (LANGUAGE-ts-mode-font-lock-level 4)
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-font-lock--file))
           (code-to-face '(
                           ("b" . font-lock-bracket-face)
                           ("B" . font-lock-builtin-face)
                           ("c" . font-lock-comment-face)
                           ;; <add-more-as-needed>
                           )))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-font-lock test-name lang-files code-to-face)))
#+end_src

* Setup: Indent

Tree-sitter indentation is defined by =treesit-simple-indent-rules=.  We create a variable
containing our N indent rules and tell tree-sitter about them. Notice that we create debug and
assert rules which are set up so that you can deploy them in production without any cost. The debug
rule is only added when =treesit--indent-verbose= is =t=. The assert rule should never be hit if
your rules cover all cases, thus it has no cost. The assert rule must be activated which we do in
the tests.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts--indent-debug-rule
    '((lambda (node parent bol)
        (message "-->N:%S P:%S BOL:%S GP:%S NPS:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-assert nil
    "Tests should set this to t to identify when we fail to find an indent rule.")

  (defvar LANGUAGE-ts-mode--indent-assert-rule
    '((lambda (node parent bol)
        (when LANGUAGE-ts-mode--indent-assert
          (error "Assert no indent rule for: N:%S P:%S BOL:%S GP:%S NPS:%S BUF:%S"
                 node parent bol
                 (treesit-node-parent parent)
                 (treesit-node-prev-sibling node)
                 (buffer-name))))
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
      `((LANGUAGE
         (MATCHER-1 ANCHOR-1 OFFSET-1)
         (MATCHER-N ANCHOR-N OFFSET-N))

        ;; I-Rule: Assert if no rule matched and asserts are enabled.
        ,LANGUAGE-ts-mode--indent-assert-rule)
      "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock.
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent.
      ;; See: ./tests/test-LANGUAGE-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))
#+end_src

To write the indent rules, we need to define the /matcher/, /anchor/, and /offset/ of each rule as
explained in the Emacs manual, "[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-based Indentation]]".  The /matcher/ and /anchor/ are
functions that take three arguments, tree-sitter =node=, tree-sitter =parent= node, and =bol=.  The
=node= can be nil when not in a node. For example, when you type return, RET, after a statement.
=bol= is the beginning-of-line buffer position. /matcher/ returns non-nil when the rule applies and
/anchor/ returns the buffer position, which along with /offset/ determines the indent level of the
line.

Let's take this basic example of our LANGUAGE, =if_else.lang= file

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

Running =M-x treesit-explore-mode= gives us:

#+begin_example
  (source_file
   (if_statement if
    condition: (comparison_operator (identifier) > (number))
    \n
    (block
     (assignment left: (identifier) =
      right: (binary_operator left: (identifier) * right: (number)))
     ;)
    (else_clause else \n
     (block
      (assignment left: (identifier) = right: (identifier))
      ;))
    end)
   \n)
#+end_example

We start with

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

Notice that we are using =(rx bos "source_file" eos)= instead of just "source_file" for our regular
expression that is matched against the parent node.  If you use =M-x ielm= and type =(rx bos
"source_file" eos)=, you see this results in the compiled regular expression ="\\`source_file\\'"=
with the start of string and end of string specifiers. We could have typed that directly, but it is
better to use the =rx= notation because it can produce more optimal regular expressions when you
have more complex regular expressions.

If you look at the definition of parent-is, you'll see it leverages =string-match-p= to do the
matching against =(treesit-node-type parent-node)=.  Therefore, to be precise, we match using the
start of the string, =bos=, and end of string, =eos=.  If your nodes are unique enough, you can
leave off the =bos= and =eos=, but that could be troublesome if the grammar is updated. For example,
suppose you have a "function" node and you match using =(parent-is "function")=, then the grammar is
updated to have regular "function" nodes and "function2" nodes where you want to different font for
"function2".  The =(parent-is "function")= will match both. Therefore, we recommend being precise
when matching which will also give a slight boost in performance.

We set

: M-: (setq treesit--indent-verbose t)

and then hit the =TAB= key on lines when vising our =if_else.lang= file:

#+begin_example
  if a > 1
      b = a * 2;
  else
      b = a;
  end
#+end_example

If we type =TAB= on the if a > 1 we'll see

 : -->N:#<treesit-node if_statement in 1-48> P:#<treesit-node source_file in 1-49> BOL:1 GP:nil NPS:nil

This gives us our first rule, =((parent-is ,(rx bos "source_file" eos)) column-0 0)= is the rule for
the root node, which in our LANGUAGE is "source_file" and says to start on column 0.

If we type  =TAB= on the "b = a * 2" line in the following =if_else.lang= file.
we'll see in the =*Messages*= buffer we'll see in the =*Messages*= buffer:

 : -->N:#<treesit-node block in 14-24> P:#<treesit-node if_statement in 1-48> BOL:14 GP:#<treesit-node source_file in 1-49> NPS:#<treesit-node "

where point 14-24 is "b = a * 2" and we see it has a node named "block". Thus, we update we add to
our indent rules, =((node-is ,(rx bos "block" eos)) parent 4)= and a couple more rules as shown
below. Notice we included a comment before each rule, which will aid in the long-term maintenance of
the code. If the font-lock rules are complex, you may also want to add ";; F-Rule: description"
comments to them.  I like using a common prefix in the comments to make the standout and searchable.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_source_file.lang
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_block.lang
       ((node-is ,(rx bos "block" eos)) parent 4)
       ;; I-Rule: <TAB> else
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_else.lang
       ((node-is ,(rx bos "else_clause" eos)) parent 0)
       ;; I-Rule: <TAB> end
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_end.lang
       ((node-is ,(rx bos "end" eos)) parent 0)
       ;; I-Rule: Assert if no rule hit
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

*Tip*: =C-M-x= in our =defvar= and re-run =M-x LANGUAGE-ts-mode= file to pick up the new indent
rules.

*Tip*: If you look at the definition, =M-x find-variable RET treesit-simple-indent-presets RET=, you
can see how the built-in /matchers/ and /anchors/ are written. From that, you can write your own as
needed.

We can simplify this because the "else_clause" and "end" nodes have the same indent rules
so we can combine them and also handle nested if-statements as shown below.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ;; I-Rule: code at start of file is located at column 0
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_source_file.lang
       ((parent-is ,(rx bos "source_file" eos)) column-0 0)
       ;; I-Rule: if a > 1
       ;;   <TAB>    b = a * 2;
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_block.lang
       ((node-is ,(rx bos "block" eos)) parent 4)
       ;; I-Rule: <TAB> if condition
       ;;         <TAB> else
       ;;         <TAB> end
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_else.lang
       ;; See: tests/test-LANGUAGE-ts-mode-indent-files/indent_end.lang
       ((node-is ,(rx bos (or "if_statement" "else_clause" "end") eos)) parent 0)

       ;; I-Rule: Assert if no rule matched and asserts are enabled.
       ,LANGUAGE-ts-mode--indent-assert-rule
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

Following this process, we complete our indent engine by adding more rules. As we develop
the rules, it is good to lock down expected behavior with tests.

** Test: Indent

We use a looping pattern similar to the font-lock test for our indent tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-indent.el
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test1.lang
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test1_expected.lang  // generated for you
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test2.lang
  ./tests/test-LANGUAGE-ts-mode-indent-files/indent_test2_expected.lang  // generated for you
  ....
#+end_example

where test-LANGUAGE-ts-mode-indent.el contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-indent--file nil)

  (defun test-LANGUAGE-ts-mode-indent--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-indent--file \"test-LANGUAGE-ts-mode-indent-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-indent--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-indent")))

  (ert-deftest test-LANGUAGE-ts-mode-indent ()
    "Test indent using ./test-LANGUAGE-ts-mode-indent-files/NAME.lang.
  Compare indent of ./test-LANGUAGE-ts-mode-indent-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang.  Indent is done two
  ways as described in `t-utils-test-indent'.  This loops
  on all ./test-LANGUAGE-ts-mode-indent-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-indent-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-indent-files/NAME_expected.lang"

    (let* ((test-name "test-LANGUAGE-ts-mode-indent")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     (rx "_expected.lang" eos) ;; skip our *_expected.lang baselines
                     test-LANGUAGE-ts-mode-indent--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-indent test-name)))
#+end_src

** Test: Indent as you type

Code should be indented correctly as you type. Consider

 : someVariable = {
 :                  ^   <== Cursor should move here when RET is typed at end of prior line

To test this we use =t-utils-xr= to execute and record editing commands. The test setup:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-indent-xr.el
  ./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1.lang
  ./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1_expected.org  // generated for you
  ....
#+end_example

where =test-LANGUAGE-ts-mode-indent-xr.el= contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-indent-xr--file nil)

  (defun test-LANGUAGE-ts-mode-indent-xr--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-indent-xr--file
        \"test-LANGUAGE-ts-mode-indent-xr-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-indent-xr--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-indent-xr")))

  (ert-deftest test-LANGUAGE-ts-mode-indent-xr ()
    "Test indent using ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang.
  Using ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang, compare typing
  commands via `t-utils-xr' Lisp commands in the *.lang files and compare
  against ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org.  This
  loops on all ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-indent-xr-files/NAME_expected.org"

    (let* ((test-name "test-LANGUAGE-ts-mode-indent-xr")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-indent-xr--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-xr test-name lang-files)))
#+end_src

An example =./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1.lang= where =%= is starts a
comment:

#+begin_example
  % -*- LANGUAGE-ts -*-
  % (t-utils-xr "C-a" "C-n" (insert "someVariable = {") "C-e" "C-m" (insert "1234") "C-m" (insert "};") "C-m" (re-search-backward "^cell") (print (buffer-substring-no-properties (point) (point-max))))
#+end_example

The execute and record function, =t-utils-xr= runs the Emacs commands which creates below the
comment line.

#+begin_example
  someVariable = {
                   1234
                 }
#+end_example

The commands are recorded into
=./tests/test-LANGUAGE-ts-mode-indent-xr-files/indent_test1_expected.org~= and compared against
baseline =indent_test1_expected.org=. If the baseline doesn't exist you are asked to review
=indent_test1_expected.org~= and rename it to indent_test1_expected.org if it looks good.

** Sweep test: Indent

We define a sweep test to be a test that tries an action on a large number of files and reports
issues it finds.  Sweep tests differ from classic baseline tests such as the above where we run
functions and check the result for correctness.  A sweep test of indent on many thousands of
LANGUAGE files cannot check the result of each individual indent because there is no baseline
results for each file. However, a sweep test can check for asserts, unexpected errors, and slow
indents. It can also check for invalid parse trees reported by the LANGUAGE tree-sitter if you have
an external command that can check for syntax errors in your LANGUAGE files.

Our indent sweep test takes a directory and runs indent-region all LANGUAGE files under the
directory recursively.

 - If the parse tree indicates an error, we call the external syntax checker to double
   check that the file does indeed have a syntax error. If the external checker says the
   file does not have a syntax error, we report the file and this is likely a bug in
   the LANGUAGE tree-sitter parser.

 - If check-valid-parse below is t the test will call syntax checker on all files being
   processed to verify that the a successful tree-sitter parse also has no errors according to
   syntax checker. Any inconsistent parses are reported which is likely a bug in the
   tree-sitter parser.

 - Next, =indent-region= is run on the file in a temporary buffer. The time it takes is
   recorded in a table.  The slowest indents are reported.  If you see slow indents, there
   could be bugs in your tree-sitter parser.

 - If =indent-region= errors out, then that is also reported.  For example, suppose we write a
   lambda indent MATCHER that contains

    : (string-match-p my-node-regexp (treesit-node-type (treesit-node-prev-sibling parent))

   In our classic test things work fine because our test has a parent with a previous
   sibling. However, we may have missed that parent may not have a previous sibling. A sweep of a
   large number of LANGUAGE files has good probability of hitting this. If parent doesn't have a
   previous sibling, we'll get "error (void-function string-match-p)."

Our indent sweep test:

#+begin_src emacs-lisp
  (require 't-utils)

  (defun sweep-test-LANGUAGE-ts-mode-indent--syntax-checker (file)
    "Syntax check FILE, return pair (VALID . CHECK-RESULT).
  Where VALID is t if the file has valid syntax, nil otherwise.
  String CHECK-RESULT is what the syntax checker command returned."
    (let ((out (shell-command-to-string
                (concat (shell-quote-argument your-syntax-checker-command)
                        " "
                        (shell-quote-argument file))))
          valid)

      (setq valid
            (not
             (string-match-p
              (rx
               (or
  	      "error:"
  	      "fatal error:"))
              out)))
      (cons valid out)))



  (defun sweep-test-LANGUAGE-ts-mode-indent (&optional directory check-valid-parse)
    "Use `LANGUAGE-ts-mode' to indent each language file in DIRECTORY.

  If DIRECTORY isn't specified, it defaults to the current directory.

  CHECK-VALID-PARSE if t, will call SYNTAX-CHECKER-FUN on all files being
  processed to verify that the a successful tree-sitter parse also has no
  errors according to SYNTAX-CHECKER-FUN.  Any inconsistent parses are
  reported which is likely a bug in the tree-sitter parser.

  This calls `t-utils-sweep-test-indent' with does a number of
  checks to validate the ident rules.  When run interactively,
  displays the result in a *t-utils-seep-indent* buffer, otherwise
  the results are displayed on stdout."

    (let ((test-name "sweep-test-LANGUAGE-ts-mode-indent")
          (LANGUAGE-ts-mode--indent-assert t))

      (t-utils-sweep-test-indent test-name
                                 (or directory default-directory)
  			       (rx ".lang" eos) ;; our language files
                                 #'LANGUAGE-ts-mode
                                 #'sweep-test-LANGUAGE-ts-mode-indent--syntax-checker
                                 check-valid-parse
                                 (rx bos "ERROR" eos))))
#+end_src

We can run our sweep test via

 : C-x C-f RET /path/to/directory/root/containing/language/files RET
 : M-: (sweep-test-LANGUAGE-ts-mode-indent)
 : M-: (sweep-test-LANGUAGE-ts-mode-indent nil t)  ;; more checking but slower

* Setup: Syntax Table

The Emacs "syntax table" is not related to the syntax tree created by tree-sitter. A syntax tree
represents the hierarchical structure of your source code, giving a structural blueprint of your
code.

Think of the syntax table as a "language character descriptor". The syntax table defines the
syntactic role of each character within the buffer containing your source code.  Characters are
assigned a syntax class which includes word characters, comment start, comment end, string
delimiters, opening and closing delimiters (e.g.  =(=, =)=, =[=, =]=, ={=, =}=), etc. The syntax
table enables natural code editing and navigating capabilities. For example, the syntax table is
used by movement commands, e.g. =C-M-f", =M-x forward-sexp=, based on syntactic expressions (words,
symbols, or balanced expressions). The syntax table is used for parentheses matching. It enables
comment operations such as =M-;=, =M-x comment-dwim=.

Below is our minimal LANGUAGE-ts-mode.el with the syntax table and comment support added. Note, our
single-line comments are of form "% comment" and block comments are of form "%{ <lines> %}". This is
set up by using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Descriptors.html][Emacs Syntax Descriptors]]. This may seem a bit obscure, but it's very elegant for
comments that start or end with one or two characters. If you have more complex syntax needs, for
example you'd like to allow "// single-line comments" but not for URL's http://location you'll need
to =(setq-local syntax-propertize-function (syntax-properties-rules ("./\\(/+\\)" (1 "."))))=.  If
you have more complex needs you'll need to set syntax-propertize-function to a function that calls
=(put-text-property start-point end-point 'category CATEGORY)=.

Notice that in our =LANGUAGE-ts-mode= definition, we set up the syntax table and comments first.
This is good practice because these are fundamental to Emacs.

#+begin_src emacs-lisp
  ;;; LANGUAGE-ts-mode.el --- comment -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;   <snip>

  ;;; Code:

  (require 'treesit)

  ;;-----------------------;;
  ;; Section: Syntax table ;;
  ;;-----------------------;;

  (defvar LANGUAGE-ts-mode--syntax-table
    (let ((st (make-syntax-table (standard-syntax-table))))
      ;; Comment Handling:
      ;; 1. Single line comments: % text (single char start),
      ;;                          note includes "%{ text"
      ;; 2. Multiline comments:   %{
      ;;                            lines
      ;;                          %}
      (modify-syntax-entry ?%  "< 13"  st)
      (modify-syntax-entry ?{  "(} 2c" st)
      (modify-syntax-entry ?}  "){ 4c" st)
      (modify-syntax-entry ?\n ">"     st)

      ;; String Handling:
      ;;   Single quoted string: 'text'
      ;;   Double-quoted string: "text"
      (modify-syntax-entry ?'  "\"" st)
      (modify-syntax-entry ?\" "\"" st)

      ;; Words and Symbols include the underscore
      (modify-syntax-entry ?_  "_" st)

      ;; Punctuation:
      (modify-syntax-entry ?\\ "." st)
      (modify-syntax-entry ?\t " " st)
      (modify-syntax-entry ?+  "." st)
      (modify-syntax-entry ?-  "." st)
      (modify-syntax-entry ?*  "." st)
      (modify-syntax-entry ?/  "." st)
      (modify-syntax-entry ?=  "." st)
      (modify-syntax-entry ?<  "." st)
      (modify-syntax-entry ?>  "." st)
      (modify-syntax-entry ?&  "." st)
      (modify-syntax-entry ?|  "." st)

      ;; Parenthetical blocks:
      ;;   Note: these are in standard syntax table, repeated here for completeness.
      (modify-syntax-entry ?\(  "()" st)
      (modify-syntax-entry ?\)  ")(" st)
      (modify-syntax-entry ?\[  "(]" st)
      (modify-syntax-entry ?\]  ")[" st)
      (modify-syntax-entry ?{   "(}" st)
      (modify-syntax-entry ?}   "){" st)

      st)
    "The LANGUAGE-ts-mode syntax table.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Syntax-table
      ;; See: ./tests/test-LANGUAGE-ts-mode-syntax-table.el
      (set-syntax-table LANGUAGE-ts-mode--syntax-table)

      ;; Comments
      (setq-local comment-start      "%")
      (setq-local comment-end        "")
      (setq-local comment-start-skip "%\\s-+")

      ;; Font-lock
      ;; See: ./tests/test-LANGUAGE-ts-mode-font-lock.el
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)
      (setq-local treesit-font-lock-feature-list '((comment definition)
  						 (keyword string type)
  						 (number bracket delimiter)
  						 (syntax-error)))

      ;; Indent
      ;; See: ./tests/test-LANGUAGE-ts-mode-indent.el
      (setq-local treesit-simple-indent-rules
                  (if treesit--indent-verbose ;; add debugging print as first rule?
                      (list (append `,(list (caar LANGUAGE-ts-mode--indent-rules))
                                    (list LANGUAGE-ts--indent-debug-rule)
                                    (cdar LANGUAGE-ts-mode--indent-rules)))
                    LANGUAGE-ts-mode--indent-rules))

      (treesit-major-mode-setup)))
#+end_src

** Test: Syntax Table

We use a looping pattern similar to the font-lock test for our syntax table tests:

#+begin_example
  ./LANGUAGE-ts-mode.el
  ./tests/test-LANGUAGE-ts-mode-syntax-table.el
  ./tests/test-LANGUAGE-ts-mode-syntax-table-files/syntax_table_test1.lang
  ./tests/test-LANGUAGE-ts-mode-syntax-table-files/syntax_table_test1_expected.lang  // generated for you
#+end_example

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-syntax-table--file nil)

  (defun test-LANGUAGE-ts-mode-syntax-table--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-syntax-table--file \"test-LANGUAGE-ts-mode-syntax-table-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-syntax-table--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-syntax-table")))

  (ert-deftest test-LANGUAGE-ts-mode-syntax-table ()
    "Test syntax-table using ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang.
  Compare ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang against
  ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.txt, where
  NAME_expected.txt gives the `syntax-ppss' value of each character in
  NAME.lang.  This loops on all ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang
  files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-syntax-table-files/NAME_expected.lang"

    (let* ((test-name "test-LANGUAGE-ts-mode-syntax-table")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-syntax-table--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-syntax-table test-name lang-files)))
#+end_src

* Setup: treesit-thing-settings

Examining treesit-major-mode-setup,

 : M-: (find-function 'treesit-major-mode-setup)

we see that with Emacs 30.1, there are three items to setup:

 : 'defun
 : 'sexp
 : 'sentence
 : 'text

='defun= is used by end-of-defun via end-of-defun-function set to treesit-end-of-defun. You should
setup ='defun= instead of treesit-defun-type-regexp for a consistent setup where all things for
navigation, etc. are all controlled by treesit-thing-settings.  If you do set
treesit-defun-type-regexp it overrides ='defun= for compatibility. The defun movement commands
you should test after setting up ='defun=:

#+begin_example
  C-M-a  Move to beginning of defun, beginning-of-defun
  C-M-e  Move to end of defun, end-of-defun
  C-M-h  Marks defun, place point at beginning of defun and mark at the end, mark-defun
#+end_example

For proper syntactic expression movement, you should define ='sexp=. Defining 'sexp requires that you
also define ='text= to cover comments and strings. ='sexp= and ='text= are used by forward-sexp and
friends (forward-sexp-function is set treesit-forward-sexp by treesit-major-mode-setup).

Syntactic expressions, s-expressions, or simply sexp commands operate on /balanced
expressions/. Strings are naturally balanced expressions because they start and end with some type
of quote character. Likewise brackets =[ items ]= and braces ={ items }= are typically balanced
expressions because they have open and close characters. Some languages have keywords expressions
that have a starting keyword and an ending keyword. For example "if" could be paired with a closing
"end" keyword. s-expressions can span multiple lines. s-expressions can be nested. These commands
leverage ='sexp= and ='text= things:

#+begin_example
  C-M-f   Move forward by s-expression, forward-sexp
          - If point is on the start of an s-expression, move to the end.
          - If point is on the end of an s-expression, move to the start of the next s-expression
            at the same level. If there is no next s-expression, no movement occurs.
  C-M-b   Move backward by s-expression, backward-sexp
          - If point is on the end of an s-expression, move to the start.
          - If point is on the start of an s-expression, move to the start of the prior s-expression
            at the same level. If there is no prior s-expression, no movement occurs.
  C-M-SPC Mark s-expression, place point at beginning of sexp and mark at the end, mark-sexp
  C-M-@   Same as C-M-SPC.
  C-M-k   Kill s-expression, kill-sexp
  C-M-t   Transpose s-expressions, transpose-sexp
#+end_example

='sentence= and ='text= are used by forward-sentence via forward-sentence-function which is set to
treesit-forward-sentence. The following sentence movement commands use forward-sentence:

#+begin_example
  M-e      Move forward to next end of sentence, forward-sentence
  M-a      Move backward to start of sentence, backward-sentence
  M-k      Kill from point to end of sentence, kill-sentence
  C-x DEL  Kill back from point to start of sentence, backward-kill-sentence
#+end_example

You can add other items to treesit-thing-settings such as ='comment= and ='string=, though
treesit.el doesn't currently use these, so I'd avoid doing so because the names you choose may not
match future items treesit.el will use.

The following commands move via parenthesis, though they are not tree-sitter aware. For example, it
would be nice if down-list / up-list could be redirected to move up and down the nested
s-expressions, but you cannot do that. Similar for forward-list, backward-list.

#+begin_example
  C-M-d   Move down into a list, down-list
  C-M-u   Move up out of a list, up-list
  C-M-n   Move forward to the next list expression in the same level, forward-list
  C-M-p   Move backward to the previous list expression in the same level, backward-list
#+end_example

TODO - explain you'll need to correct forward-sexp when in comments

#+begin_src emacs-lisp
    (treesit-major-mode-setup)

    ;; Correct forward-sexp setup created by `treesit-major-mode' so that in comments we do normal
    ;; s-expression matching using parenthesis. This fix is need for our tests were we need
    ;; to evaluate (t-utils-NAME ....) expressions from within comments using C-x C-e.
    (setq-local forward-sexp-function #'LANGUAGE-ts-mode--forward-sexp)
#+end_src

** Test: treesit-thing-settings

TODO

* Setup: Fill Paragraph, M-q

=M-q= is bound to =prog-fill-reindent-defun= from =prog-mode=, which when the point is in a comment
will fill the comment. If the point is in code it will indent the code. If the point is in a string,
M-q will fill the string like it's plain text, which can result in syntax errors. This is expected
behavior because one can then fix the syntax behaviors by adding appropriate string
continuations. There's no way to alter the string filling behavior besides using defadvice, which
you should not do.

If your syntax table correctly identifies comments and strings, then it M-q just works, though you
should still add tests to validate it works.  If you'd like tree-sitter nodes other than comments
and strings to be filled like plain text, you should add a =text= entry to =treesit-thing-settings=,
e.g. if nodeName1 and nodeName2 should be filled like plain text, use:

 #+begin_src emacs-lisp
 (defvar LANGUAGE-ts-mode--thing-settings
  `((LANGUAGE
     (text ,(rx (or "nodeName1" "nodeName2" ....))))))
 #+end_src

and in defun of LANGUAGE-ts-mode, add =(setq-local treesit-thing-settings
LANGUAGE-ts-mode--thing-settings)= after you've setup your syntax table.

** Test: Fill Paragraph

TODO

* Setup: treesit-defun-name-function

Emacs supports the concept of Change Logs for documenting changes.  With version control systems
like git, there's less need for Change Logs, though the format of the Change Logs.  In Emacs using
=C-x 4 a= (add-change-log-entry-other-window) will end up calling =add-log-current-defun= which
defers to the =treesit-defun-name-function= to get information for the entry to add to the log file.

TODO

** Test: treesit-defun-name-function

TODO

* Setup: IMenu

Emacs =M-g i= (=M-x imenu=), makes it easy to jump to items in your file. If our mode populates
imenu with the location of the function definitions, we can quickly jump to them by name. You can
also leverage [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Which-Function.html][M-x which-function-mode]] to have Emacs display the imenu entry for the current point in
the mode line. You can view imenu in a sidebar window, using, [[https://github.com/oantolin/embark][embark]], [[https://github.com/rnkn/side-hustle][side-hustle]], or [[https://github.com/bmag/imenu-list][imenu-list.]]

To populate imenu, in LANGUAGE-ts-mode, we setup =treesit-simple-imenu-settings=, where each element
is of form =(category regexp pred name-fn)=, but form many languages, you only need to specify the
first two elements.  When name-fcn is nil the imenu names are generated the
=treesit-defun-name-function= which we already setup.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--imenu-settings
    `(("Class" ,(rx bos "class_definition" eos))
      ("Function" ,(rx bos "function_definition" eos)))
    "Tree-sitter imenu settings.")

  ;; <snip>

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
    ;; <snip>
    (setq-local treesit-defun-name-function #LANGUAGE-ts-mode--defun-name)
    (setq-local treesit-simple-imenu-settings LANGUAGE-ts-mode--imenu-settings)
    ;; <snip>
    )
#+end_src

Alternatively, for complex languages, you can =(setq-local imenu-create-index-function
#'LANGUAGE-ts-mode--imenu-create-index)= and within =LANGUAGE-ts-imenu-create-index=, walk the
tree-sitter parse tree and generate the index.

TODO

** Test: IMenu

TODO

* Setup: Outline, treesit-outline-predicate

This needs to be setup if treesit-simple-imenu-settings isn't set and you are using a custom
imenu-create-index-function as we did above.

TODO

** Test: Outline

* Setup: Electric Pair, electric-pair-mode

=M-x electric-pair-mode= for most languages will just work. However, if your language
uses typical characters that are paired, e.g. a single quote for a string delimiter and
also an operator such as a transpose, then you'll need to:

#+begin_src emacs-lisp
  (declare-function electric-pair-default-inhibit "elec-pair")
  (defun LANGUAGE-ts-mode--electric-pair-inhibit-predicate (char)
    "Return non-nil if `electric-pair-mode' should not pair this CHAR.
  Do not pair the transpose operator, (\\='), but pair it when used as a
  single quote string."

    ;; (point) is just after CHAR. For example, if we type a single quote:
    ;;   x = '
    ;;        ^--(point)

    (cond
     ;; Case: Single quote
     ((eq char ?')
      ;; Look at the tree-sitter nodes and return t if the pairing should be inhibited.
      ;; <snip>
      )

     ;; Case: Not a single quote, defer to the standard electric pair handling
     (t
      (funcall #'electric-pair-default-inhibit char))))

  ;; <snip>
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"

    ;; <snip>

    ;; Electric pair mode
    (setq-local electric-pair-inhibit-predicate #'LANGUAGE-ts-mode--electric-pair-inhibit-predicate)
    )
#+end_src

** Test: Electric Pair

* Setup: show-paren-mode

show-paren-mode uses =show-paren-data-function= to match "start" with "end" pairs. For example:

 : myfcn(1, 2, 3)                  x = {1, 2, 3, 4}
 :      ^       ^                      ^          ^
 :    here     there                  here       there

Your programming language may have other items that should be paired. You can leverage
show-paren-mode as a general "show pair mode". For example, you can extend show-paren-mode
to show matching start/end quotes in a string:

 : s = "foo bar"
 :     ^       ^
 :    here    there

If your programming language has block-like keywords, we can pair them. For example:

 :  if condition
 :  ^
 :      myfcn(1, 2, 3)
 :  end
 :  ^

To extend show-paren-mode, we set =show-paren-data-function= for our mode. Below we illustrate
how to do string matching assuming strings can be created using ='single quotes'= or
="double quotes"= where the string tree sitter nodes are:

  : (string " (string_content) ")
  : (string ' (string_content) ')

#+begin_src emacs-lisp
  (declare-function show-paren--default "paren")

  (defun LANGUAGE-ts-mode--show-paren-or-block ()
    "Function to assign to `show-paren-data-function'.
  Highlight LANGUAGE pairs in addition to standard items paired by
  `show-paren-mode'.  Returns a list: \\='(HERE-BEGIN HERE-END THERE-BEGIN
  THERE-END MISMATCH) or nil."
    (let* (here-begin
           here-end
           there-begin
           there-end
           mismatch
           (pt (point))
           (node (treesit-node-at pt)))

      ;; If point is in whitespace, (treesit-node-at (point)) returns the nearest node. For
      ;; paired matching we want the point on either a start or end paired item.
      (let ((node-start (treesit-node-start node))
            (node-end (treesit-node-end node)))
        (when (and (>= pt node-start)
                   (<= pt node-end))
          (let* ((node-type (treesit-node-type node))
                 (parent-node (treesit-node-parent node))
                 (parent-type (treesit-node-type parent-node)))

            (cond

             ;; Case: on a single or double quote for a string.
             ((and (or (equal "'" node-type)
                       (equal "\"" node-type))
                   (equal "string" parent-type))
              (let (q-start-node
                    q-end-node)
                (if (= (treesit-node-start parent-node) (treesit-node-start node))
                    ;; looking at start quote
                    (setq q-start-node node
                          q-end-node parent-node)
                  ;; else looking at end quote
                  (setq q-start-node parent-node
                        q-end-node node))

                (setq here-begin (treesit-node-start q-start-node))
                (setq here-end (1+ here-begin))

                (let* ((candidate-there-end (treesit-node-end q-end-node))
                       (candidate-there-begin (1- candidate-there-end)))
                  (cond
                   ;; Case: Have starting quote of a string, but no content or closing quote.
                   ((= here-begin candidate-there-begin)
                    (setq mismatch t))
                   ;; Case: Have starting quote, have string content, but no closing quote
                   ((not (equal (char-after here-begin) (char-after candidate-there-begin)))
                    (setq mismatch t))
                   (t
                    (setq there-begin candidate-there-begin)
                    (setq there-end candidate-there-end))))))

             ;; Add cases for other pairs.
             ;; Note set mismatch to t if we have say a start keyword of a pair
             ;; but are missing the end keyword.

             ))))

      (if (or here-begin here-end)
          (list here-begin here-end there-begin there-end mismatch)
       (funcall #'show-paren--default))))

    (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE:ts"
      "Major mode for editing LANGUAGE files with tree-sitter."
      ;; <snip>
      (setq-local show-paren-data-function #'LANGUAGE-ts-mode--show-paren-or-block)
    )
#+end_src

** Test: show-paren-mode

Test file structure:

 : LANGUAGE-ts-mode.el
 : tests/test-LANGUAGE-ts-mode-show-paren.el
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM1.LANG
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM1_expected.org
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM2.LANG
 : tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM2_expected.org
 : ...

where =tests/test-LANGUAGE-ts-mode-show-paren.el= contains:

#+begin_src emacs-lisp
  (require 't-utils)
  (require 'LANGUAGE-ts-mode)

  (defvar test-LANGUAGE-ts-mode-show-paren--file nil)

  (defun test-LANGUAGE-ts-mode-show-paren--file (lang-file)
    "Test an individual LANG-FILE.
  This is provided for debugging.
    M-: (test-LANGUAGE-ts-mode-show-paren--file \"test-LANGUAGE-ts-mode-show-paren-files/LANG-FILE\")"
    (let ((test-LANGUAGE-ts-mode-show-paren--file lang-file))
      (ert-run-tests-interactively "test-LANGUAGE-ts-mode-show-paren")))

  (ert-deftest test-LANGUAGE-ts-mode-show-paren ()
    "Test show paren mode using ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang.
  Using ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang, result of
  `LANGUAGE-ts-mode--show-paren-or-block' for `show-paren-mode' against
  ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org.  If LANG-FILE is
  not provided, loop comparing all
  ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang files.

  To add a test, create
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME.lang
  and run this function.  The baseline is saved for you as
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org~
  after validating it, rename it to
    ./test-LANGUAGE-ts-mode-show-paren-files/NAME_expected.org"

    (let* ((test-name "test-LANGUAGE-ts-mode-show-paren")
           (lang-files (t-utils-get-files
                     test-name
                     (rx ".lang" eos)
                     nil
                     test-LANGUAGE-ts-mode-show-paren--file)))
      (t-utils-error-if-no-treesit-for 'LANGUAGE test-name)
      (t-utils-test-xr test-name lang-files)))
#+end_src

Each =tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM.LANG= file looks like the
following assuming we have =% comment=" lines, replace with your language comments.

#+begin_example

  // -*- LANGUAGE-ts -*-

    <snip - code to define string variables>

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s1 = '<foo '' bar>';

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s2 = '<foo '' bar>';

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s3 = "<foo ' bar>";

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s4 = "<foo ' bar>";

% (t-utils-xr (re-search-forward "<") "C-b" "C-b" (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s5 = "<asdf

% (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))
s6 = asdf>"

    <snip>

#+end_example

The tests are using the execute and record function, =t-utils-xr= which runs commands and records
them into a =*.org= file. We run the test and if
=tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM_expected.org= doesn't exist,
=tests/test-LANGUAGE-ts-mode-show-paren-files/show_paren_ITEM_expected.org~= will be generated and
after inspection rename the =*.org~= to =*.org=.

For example, the last t-utils-xr result in the *.org file is below. Notice, that standard-output is
"(910 911 nil nil t)" which indicates we have here-begin and here-end, but no there-begin and no
there-end with mismatch true (t) because the string is missing the starting quote.

#+begin_src org
  ,* Executing commands from show_paren_string.lang:25:2:

    (t-utils-xr (re-search-forward ">") (prin1 (LANGUAGE-ts-mode--show-paren-or-block)))

  - Invoking      : (re-search-forward ">")
    Start point   :  899
    Moved to point:  910
    : 26:10: s6 = asdf>"
    :                  ^
    No buffer modifications

  - Invoking      : (prin1 (LANGUAGE-ts-mode--show-paren-or-block))
    Start point   :  910
    No point movement
    standard-output:
      (910 911 nil nil t)
    No buffer modifications
#+end_src

* Setup: Handling Corrupted Content

Corrupted content in LANGUAGE, NAME.LANG, files can crash Emacs when your tree-sitter
language shared library runs on the corrupted content.  For example, try load a large
binary file and =M-x LANGUAGE-major-mode=.  Since content should be utf-8, you should add
to the start of your LANGUAGE-major-mode:

#+begin_src emacs-lisp
  (defun LANGUAGE-ts-mode--check-file-encoding ()
    "Check file encoding.
  Error is signaled if contents are corrupt because non-utf8 printable
  content can crash Emacs via the LANGUAGE tree-sitter parser."

    (let ((bad-char-point (save-excursion
                            (goto-char (point-min))
                            (when (re-search-forward "[^[:print:][:space:]]" nil t)
                              (point)))))
      (when bad-char-point
        (fundamental-mode)
        (goto-char bad-char-point)
        (user-error "Buffer appears corrupt, non-printable utf8 character at point %d: %c"
                    bad-char-point (char-before)))))


  (define-derived-mode matlab-ts-mode prog-mode "LANGUAGE:ts"
    "Documentation."

    (LANGUAGE-ts-mode--check-file-encoding)

    (when (treesit-ready-p 'LANGUAGE)
      ;; <snip>
      ))
#+end_src

** Test: Handling Corrupted Content

Test setup:

 #+begin_example
 ./LANGUAGE-ts-mode.el
 ./tests/test-LANGUAGE-ts-mode-file-encoding.el
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME1.LANG
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME1_expected.txt
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME2.LANG
 ./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME2_expected.txt
 ....
 #+end_example

=./tests/test-LANGUAGE-ts-mode-file-encoding.el= contains:

  #+begin_src emacs-lisp
    (require 't-utils)
    (require 'LANGUAGE-ts-mode)

    (defvar test-LANGUAGE-ts-mode-file-encoding--file nil)

    (defun test-LANGUAGE-ts-mode-file-encoding--file (lang-file)
      "Test file-encoding on LANG-FILE."
      (let ((test-LANGUAGE-ts-mode-file-encoding--file lang-file))
        (ert-run-tests-interactively "test-LANGUAGE-ts-mode-file-encoding")))

    (ert-deftest test-LANGUAGE-ts-mode-file-encoding ()
      (let* ((test-name "test-LANGUAGE-ts-mode-file-encoding")
             (lang-files (t-utils-get-files
                       test-name
                       (rx ".lang" eos)
                       nil
                       test-LANGUAGE-ts-mode-file-encoding--file)))
        (t-utils-error-if-no-treesit-for \\='LANGUAGE test-name)
        (t-utils-test-file-encoding test-name lang-files \\='#LANGUAGE-ts-mode)))
  #+end_src

Create /tests/test-LANGUAGE-ts-mode-file-encoding-files/*.LANG files containing corrupted
(non-utf-8) content. Also create at least one valid *.LANG files.

Run the test:

 : M-x ert RET test-LANGUAGE-ts-mode-file-encoding RET

In the =ert= result buffer, you can type \"m\" at the point of the test (where
the color marker is) to see messages that were displayed by your test.

If the =./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME*_expected.txt~= files look good
rename them to =./tests/test-LANGUAGE-ts-mode-file-encoding-files/NAME*_expected.txt= (per the
messages shown by ert).

* Final version

TODO

* Summary

Tree-sitter powered modes provide highly accurate syntax coloring, indentation, and other features.
In addition, tree-sitter modes are generally much more performant than the older-style regular
expression based modes, especially for a reasonably complex programming language.

A downside of a tree-sitter mode is that the necessary =libtree-sitter-LANGUAGE.SLIB= shared library
files are not provided with the =NAME-ts-mode='s that are shipped with Emacs. For =NAME-ts-mode='s
that are installed via =M-x package-install LANGUAGE-ts-mode=, the corresponding
=libtree-sitter-LANGUAGE.SLIB= shared libraries are not installed.  You can have Emacs build
=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB= via =M-x treesit-install-language-grammar=, but
this can result in shared libraries that do not run correctly because of a compiler version mismatch
between what was used for Emacs and what was used to build =libtree-sitter-LANGUAGE.SLIB=.

Another problem with =M-x treesit-install-language-grammar= is that it doesn't specify the
application binary interface (ABI) version when building. For example, Emacs 30.1 is at ABI 14
=(treesit-library-abi-version)=, and tree-sitter is at 15 and if you attempt to use what
=M-x treesit-install-language-grammar= creates, you'll see:

 : Warning (treesit): The installed language grammar for LANGUAGE cannot be located or has problems (version-mismatch): 15

Ideally, =M-x treesit-install-language-grammar= would be updated to do more error checking to
ensure the right compilers are in place and specify the ABI version. Something like:

 : tree-sitter generate --abi 14
 : gcc src/*.c -I./src -o ~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.so --shared -fPIC -Os

As of Jun-2025, for Emacs 30.1, you can copy the prebuilt shared library, LANGUAGE.SLIB, from
https://github.com/emacs-tree-sitter/tree-sitter-langs and place it in
=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=. Note, Emacs will first look for
=libtree-sitter-LANGUAGE.SLIB= in =treesit-extra-load-path=, then in subdirectory =tree-sitter= under
=user-emacs-directory= (=~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.SLIB=), then in the system
=/lib=.

These downsides are relatively minor compared with the benefits of a tree-sitter powered mode. It is
well worth writing a tree-sitter mode.

* Appendix: t-utils.el

See [[file:../tests/t-utils.el]]. For now copy this to your repository.  It would be nice to integrate
t-utils.el into the Emacs ert package, perhaps ert-ts.el? Alternatively, we could create a separate
ELPA package for it?

TODO extract help from t-utils.el and place here.

* Issues

- [ ] Building libtree-sitter-matlab.dll from src on Windows produces a DLL that fails.

  - Install MSYS2
  - Run MSYS2 bash, then: pacman -S gcc
  - Install gpg from https://www.gpg4win.org/ and place it on the path before MSYS2.
  - Install matlab tree sitter from src using Emacs 30.1
  #+begin_example
    emacs
    M-x treesit-install-language-grammar
    Language: matlab
    There is no recipe for matlab, do you want to build it interactively? (y or n) y
    Enter the URL of the Git repository of the language grammar: https://github.com/acristoffers/tree-sitter-matlab
    Enter the tag or branch (default: default branch): abi/14
    Enter the subdirectory in which the parser.c file resides (default: "src"):
    Enter the C compiler to use (default: auto-detect):
    Enter the C++ compiler to use (default: auto-detect):
    Install to (default: ~/.emacs.d/tree-sitter):
  #+end_example

  The resulting dll is bad. Maybe gcc 13 is not a valid version of gcc.

  Note the build of the dll from https://github.com/emacs-tree-sitter/tree-sitter-langs is good.

- [ ] In [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-Based Indentation]] we have prev-line which goes backward exactly one line

  Consider a programming language with a few statements, e.g.

  #+begin_example
    {
        a = 1;
        b = 2;

    }
  #+end_example

  If you use prev-line on the blank-line immediately after "b = 2;", you'll get the expected
  point below "b". If you use prev-line on the second blank line after "b = 2;", you'll get
  0, which is unexpected in many languages. I suspect it may be safe to just update prev-real
  line too look backwards to the first prior line with non-whitespace or if you are worried
  about compatibility, introduce:

  #+begin_src emacs-lisp
    (cons 'prev-real-line (lambda (_n _p bol &rest _)
    			(save-excursion
    			  (goto-char bol)
    			  (forward-line -1)
    			  (while (and (not (bobp))
    				      (looking-at "^[ \t]*$"))
    			    (forward-line -1))
    			  (skip-chars-forward " \t")
    			  (point))))
  #+end_src

- [ ] M-q (prog-fill-reindent-defun), when the point is in a string and you type M-q it will
  split long strings into multiple lies which results in syntax errors in some languages, e.g. C.

  : char * str = "a very long string a very long string a very long string a very long string a very long string a very long string a very long string a very long string ";

  results in:

  TODO validate this occurs with c-ts-mode.

  Would like an option to have M-q indent or fill comments. When in a string it should do nothing
  if it can't guarantee the syntax will be correct. Ideally, we'd have a way to fill strings
  by using the appropriate string concatenation characters.

- [ ] Doc for https://www.gnu.org/software/emacs/manual/html_mono/elisp.html is misleading.
  It mentions a "comment" thing, but that is not used by treesit. Also looking at the
  setting for C/C++, what's written

   : Here's an example treesit-thing-settings for C and C++:
   :
   : ((c
   :   (defun "function_definition")
   :   (sexp (not "[](),[{}]"))
   :   (comment "comment")
   :   (string "raw_string_literal")
   :   (text (or comment string)))
   :  (cpp
   :   (defun ("function_definition" . cpp-ts-mode-defun-valid-p))
   :   (defclass "class_specifier")
   :   (comment "comment")))

  doesn't match treesit.el. What about just stating what is needed:

  TODO

- [ ] In https://www.gnu.org/software/emacs/manual/html_node/elisp/Major-Mode-Conventions.html

  Major Mode Conventions:

  - The major mode command should start by calling kill-all-local-variables. This runs the normal
    hook change-major-mode-hook, then gets rid of the buffer-local variables of the major mode
    previously in effect. See Creating and Deleting Buffer-Local Bindings.

  However, existing Emacs 30.1 modes like c-ts-mode do not call this?

  TODO verify

* News for matlab-ts-mode

  1. Improved font-lock (semantic coloring) performance, making editing even more smooth.

     - More accurate fontification, we now identify language elements accurately and use
       more faces to color them.

     - Fixes edge-case fontification issues when compared with matlab-mode

       Create issue for this:
         #+begin_src matlab-ts
         x = [1 2; 3 4];
         y = x''               % this is valid double transpose where matlab-mode gets it wrong
         #+end_src

       Function identification, see https://github.com/mathworks/Emacs-MATLAB-Mode/issues/48

     - In comments, we now highlight =FIXME=, =TODO=, and =XXX= markers.

     - Fixed fontification of "%% section" to require that the be the start of a comment and
       on their own line.

     - Variable creation/assignment will be semantically colored.

     - Now fontify all MATLAB/Simulink factory builtin provided functions, class
       methods/properties, enums, etc. Note, if you override a builtin function with a variable,
       the variable creation/assignment will be colored as a variable, but the use will continue to
       be a function.  To avoid this confusing state, use variable names that collide with builtin
       items.

  2. Improved indent

     - Simplified the semantics for indent. The indent rules are:

       + TODO

     - Improved indent performance, making editing even more smooth.

     - Fixes various edge-case indent issues, some are

       + Fixed indent of function definition when ellipsis continuations are used.

       + Auto-indentation of end, see https://github.com/mathworks/Emacs-MATLAB-Mode/issues/33

       + TODO

  3. There's no longer prompting if you want functions to have end's. This is now computed
     automatically.

  4. Improved fill-paragraph, =M-q=, which will now fill comments and when not in a comment, indent
     the current function or statement.

  5. Accurate type of m-file detection, which improves matlab-sections-minor-mode.

     + TODO

  6. Change Log command now work with MATLAB *.m files.

     Running =C-x 4 a= (add-change-log-entry-other-window) will now insert the name of the function
     or classdef for the current point.

  7. Added support for =M-x outline-minor-mode=. Outline headings are =function='s, =classdef='s,
     and "%% heading" comments.

  8. On save fix of function/classdef name now handles buffer names that aren't valid MATLAB
     identifiers.  On save fix of function/classdef name handles buffers not associated with files
     on disk.  Also fixed cases where detection of scripts failed.

  9. Improved handling of single quotes for =M-x electric-pair-mode=. These will automatically
     pair
     - Single quote when used to create a single-quoted string, but not when used elsewhere,
       e.g. a matrix transpose.
     - Double quotes for a double-quoted string.
     - Parenthesis =()=, Vectors, =[]=, and Cells ={}=.

 10. We now highlight starting and ending string quote when the point is on the start or end single
     or double quote.

 11. Improved (more predictable) s-expression commands

     #+begin_example
       C-M-f   Move forward by s-expression, forward-sexp
               - If point is on the start of an s-expression, move to the end.
               - If point is on the end of an s-expression, move to the start of the next s-expression
                 at the same level. If there is no next s-expression, no movement occurs.
       C-M-b   Move backward by s-expression, backward-sexp
               - If point is on the end of an s-expression, move to the start.
               - If point is on the start of an s-expression, move to the start of the prior s-expression
                 at the same level. If there is no prior s-expression, no movement occurs.
       C-M-SPC Mark s-expression, place point at beginning of sexp and mark at the end, mark-sexp
       C-M-@   Same as C-M-SPC.
       C-M-k   Kill s-expression, kill-sexp
       C-M-t   Transpose s-expressions, transpose-sexp
     #+end_example

 12. Improved sentence commands. Also fixes bugs, e.g. M-a in old matlab-mode can result in error
     "Wrong number of arguments: (0 . 0), 1" and now works in matlab-ts-mode.

     #+begin_example
       M-e      Move forward to next end of sentence, forward-sentence
       M-a      Move backward to start of sentence, backward-sentence
       M-k      Kill from point to end of sentence, kill-sentence
       C-x DEL  Kill back from point to start of sentence, backward-kill-sentence
     #+end_example

 13. Many older matlab-mode menu items and keybindings have been removed because there are
     standard replacements. Examples:

     - To comment or uncomment code use select the code and type =M-;= which is the standard
       way to do this in Emacs. The older =C-c ;= and =C-c :" matlab only comment and uncomment
       commands no longer exist.

     - Completion - we used to have =M-TAB= to complete symbol and this has been replaced by
       using LSP mode.

       TODO - show how to do in lsp-mode and update lsp-mode org on this.

# LocalWords:  showall usepackage parskip tocloft cftsecnumwidth cftsubsecindent cftsubsecnumwidth
# LocalWords:  lang utils Imenu LSP defun ELPA tuils setq SLIB libtree dylib sexp xr defcusom
# LocalWords:  defface EDebug ielm fontify Fontifying fontified defcustom alist eos bol NPS prev BUF
# LocalWords:  caar cdar bos dwim propertize ppss SPC reindent defadvice IMenu imenu pred fn elec
# LocalWords:  funcall myfcn prin asdf repeat:nil ABI abi MSYS pacman gpg bobp defclass
# LocalWords:  fontification lsp
