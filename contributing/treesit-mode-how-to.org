# File: contributing/treesit-mode-how-to.org

# | Copyright 2025 Free Software Foundation, Inc.
# |
# | This program is free software: you can redistribute it and/or modify
# | it under the terms of the GNU General Public License as published by
# | the Free Software Foundation, either version 3 of the License, or
# | (at your option) any later version.
# |
# | This program is distributed in the hope that it will be useful,
# | but WITHOUT ANY WARRANTY; without even the implied warranty of
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# | GNU General Public License for more details.
# |
# | You should have received a copy of the GNU General Public License
# | along with this program.  If not, see <http://www.gnu.org/licenses/>.
# |
# | Commentary:
# |   Guidelines for writting a major mode powered by tree-sitter

#+title: Tree-Sitter How To
#+author: John Ciolfi
#+date: Jun-22-2025

* TODO

- [ ] Add how to setup comments and syntax table
- [ ] Add indent assert rule
- [ ] Add font-lock test
- [ ] Add indent tests
- [ ] Add feature-based test for indent
      - (directory-files-recursively DIR "\\.m$")
      - On each file, check parse tree for ERROR nodes and see if it really has an error by running
        matlab/bin/arch/mlint and looking for "Parse error". If no parse error, then flag these as
        issues with the matlab tree-sitter.
      - Indent the file to see if matlab-ts-mode--indent-assert-rule fires

* Guide to building a tree-sitter mode

This is a set of notes that I'm taking as I develop matlab-ts-mode.el with the goal of this becoming
a guide for writting a tree-sitter mode.

This guide assumes was written when using Emacs 30.1 and the goal is to create *LANGUAGE-ts-mode*
for /file.lang/ files.

In creating a tree-sitter mode for a programming lanugage, you have two options. Releverage an
old-style existing mode via =(define-derived-mode LANGUAGE-ts-mode OLD-LANGUAGE-mode "LANGUAGE"
...)= and overriding items such as font-lock and indent. The other approach is
to create a new LANGUAGE-ts-mode based on prog-mode which we recommend to eliminate coupling between
the old-style mode and the new tree-sitter mode.

#+begin_src emacs-lisp
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE" ...)
#+end_src

To create the mode, we recommend following this order:

1. *Font-lock*. We suggest doing this first, so that /file.lang/ is syntatically colored when
   viewing it.
2. *Indent*. Next we setup indentation so that you can edit /file.lang/ easily.
3. *Syntax table and comments*.
4. *Navigation*. Setup treesit-defun-type-regexp and treesit-defun-name-function to enable navigation
   features like beginning-of-defun and end-of-defun
5. *Imenu*

** Documentation

 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html][Emacs manual: Parsing Program Source]]
 - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Emacs manual: Parser-based Indentation]]

* Syntax trees and queries

If you are not familar with the concepts behind tree-sitter, see
https://tree-sitter.github.io/tree-sitter. In particular, learn the notion of queries and try out
queries in the playground section of the site on one of the languages supported by the site. A
good understanding of the syntax tree and queires are required to implement a new tree-sitter
major mode. You don't need to understand how to implement a lanugage parser if one already
exists, otherwise you'll need to write a tree-sitter language parser.

The tree-sitter parser produces a syntax tree:

#+begin_example
  +-------+     +-----------------------------+
  |       |     |                             |
  | Emacs |<===>| libtree-sitter-LANUGAGE.EXT |
  |       |     |                             |
  +-------+     +-----------------------------+
#+end_example

The libtree-sitter-LANUAGE.EXT shared library (EXT = .so on Linux, .dll on Windows, or .dylib on
Mac) is used to create a syntax tree of LANUAGE:

#+begin_example
  LANUAGE program             Syntax Tree

   c = a + b                      =
                                /   \
                               c     +
                                   a   b
#+end_example

Each node in the syntax tree knows it start point and end point in the LANGUAGE program. The
parser is fast and incrementally updates as you type. The memory required to represent the syntax
tree is roughly 10 times the text size of the program being analyzed. However, the benefits of
tree sitter are highly accuracte and fast syntax coloring (font-lock), indentation, code
navigation via syntatic expressions, etc.

* libtree-sitter-LANGUAGE.EXT

Place the tree-sitter language library in =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT=
(EXT=.so on Linux, .dll on Windows, .dylib on Mac). There are other locations that this can
reside in, though =~/.emacs.d/tree-sitter/= is the default.

- You can grab the LANGUAGE.EXT from https://github.com/emacs-tree-sitter/tree-sitter-langs/releases
  and rename it to =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT=.

- You can build it using

  : M-x treesit-install-language-grammar

Next, create a basic LANGUAGE-ts-mode.el to validate your tree-sitter shared library is good.

It is possible that =~/.emacs.d/tree-sitter/libtree-sitter-LANGUAGE.EXT= was built incorrectly,
so we create the following to validate it, replacing LANGUAGE with your language name.

#+begin_src emacs-lisp
  ;; Basic LANGUAGE-ts-mode.el

  (require 'treesit)

  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files with tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)
      (treesit-major-mode-setup)))

  (provide 'LANGUAGE-ts-mode)

#+end_src

Validate your LANGAUGE-ts-mode works. Create foo.txt containing valid LANGUAGE content, then open
foo.txt in Emacs and run:

: M-x LANGUAGE-ts-mode

You should now be able to use:

: M-x treesit-inspect-mode
: M-x treesit-explore-mode

* Debugging tips

- Incremental updates to your LANGUAGE-ts-mode

   As you update =LANUGAGE-ts-mode.el= you need to tell Emacs to pickup the updates. To do this,

    - Use *=C-x C-e=*. With the cursor =(point)= at the end of the syntatic expression of your *.el
      file and run =C-x C-e= (or =M-x eval-last-sexp=) to evaluate the sexp prior to the cursor
      point.

    - Alternatively, use *=C-M-x* (or =M-x eval-defun=). With the =(point)= in the =defvar=,
      =defcusom=, or =defface=, run =C-M-x= to evaluate it.

   Note: =M-x eval-buffer= will not reevaluate already defined =defvar='s, so you must use
   one of the above two to update a =defvar=.

- =M-x LANGUAGE-ts-mode=

 - After making updates to =LANGUAGE-ts-mode.el= and evaluating them, you run =M-x LANGUAGE-ts-mode=
   to re-load your mode in your =test.lang= file. For example, when writing the indent rules, you'll
   need to run =M-x LANGUAGE-ts-mode= after =M=x eval-defun= on in your =(defvar
   LANGUAGE-ts-mode--indent-rules ....)=.

- Use =M-x ielm=

  In the =*ielm*= buffer created by =M-x ielm=, you can examine tree-sitter nodes, etc. For example:

  #+begin_example
  ELISP> (with-current-buffer "test.lang"
	 (treesit-node-parent (treesit-node-at (point))))
  #+end_example

* Font-lock

Queries are needed to identify syntax tree nodes to fontify. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-Matching.html][Emacs manual - Pattern Matching
Tree-sitter Nodes]].

You can use =M-x treesit-explore-mode= to see the nodes of the syntax tree.

An example of a query that identifies comments (assuming =comment= is a valid node type), in a
file that has =M-x LANGUAGE-ts-mode= active.

: M-: (treesit-query-capture (treesit-buffer-root-node) '((comment) @comments))

Suppose your lanugage contains the keyword "if", you can find all "if" keywords using:

: M-: (treesit-query-capture (treesit-buffer-root-node) '("if" @keywords))

To capture all keywords of your language, use alternation. Here we are capturing the "if"
and "else" keywords:

: M-: (treesit-query-capture (treesit-buffer-root-node) '(["if" "else"] @keywords))

Note, to validate your queries use:

: M-x (treesit-query-validate 'LANGUAGE '(QUERRY @catpture-name))

Once we know the queries, we can setup font-lock. For example, here we fontify comments
and keywords.

#+begin_src emacs-lisp
  (require 'treesit)

  (defvar LANGUAGE-ts-mode--keywords
      '("else"
        "if"
        ;; <snip>
        )
    "LANGUAGE keywords for tree-sitter font-locking.")

  (defvar LANGUAGE-ts-mode--font-lock-settings
    (treesit-font-lock-rules
     :language 'LANGUAGE
     :feature 'comment
     '((comment) @font-lock-comment-face)

     :language 'LANGUAGE
     :feature 'keyword
     `([,@LANGUAGE-ts-mode--keywords] @font-lock-keyword-face)))
    "LANGUAGE tree-sitter font-lock settings.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Font-lock
      (setq-local treesit-font-lock-settings LANGUAGE-ts-mode--font-lock-settings)

      ;; `treesit-font-lock-feature-list' contains four sublists where the first
      ;; sublist is level 1, and so on.  Each sublist contains a set of feature
      ;; names that correspond to the
      ;;   :feature 'NAME
      ;; entries in LANGUAGE-ts-mode--font-lock-settings.  For example, 'comment for comments,
      ;; 'definition for function definitions, 'keyword for language keywords, etc. Below
      ;; we have a few examples. You can use any names for your features.
      ;; Font-lock applies the faces defined in each sublist up to and including
      ;; `treesit-font-lock-level', which defaults to 3.
      (setq-local treesit-font-lock-feature-list
          	'((comment definition)
                    (keyword string type)
                    (number)
                    (bracket delimiter error)))

      (treesit-major-mode-setup)))
#+end_src

Notice how the @capture-name in the comment query is @font-lock-comment-face. This face is
applied to the items captured by the query. You can see available faces by using =M-x
list-faces-display=.  You'll probably want to stick with faces that come with stock Emacs to
avoid dependenices on other packages or create your own face.

* Comments

TODO

* Indent

Tree-sitter indentation is controlled by =treesit-simple-indent-rules=.  We create a variable
containing our N indent rules and tell tree-sitter about them

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
      `((LANGUAGE
         (MATCHER-1 ANCHOR-1 OFFSET-1)
         (MATCHER-N ANCHOR-N OFFSET-N)))
      "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")

  ;;;###autoload
  (define-derived-mode LANGUAGE-ts-mode prog-mode "LANGUAGE"
    "Major mode for editing LANGUAGE files using tree-sitter."

    (when (treesit-ready-p 'LANGUAGE)
      (treesit-parser-create 'LANGUAGE)

      ;; Indent
      (setq-local treesit-simple-indent-rules LANGUAGE-ts-mode--indent-rules)

      (treesit-major-mode-setup)))
#+end_src

To write the indent rules, we need to define the /matcher/, /anchor/, and /offset/ of each rule as
explained in the Emacs manual, "[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-based Indentation]]".  The /matcher/ and /anchor/ are are
functions that take three arguments, =node=, =parent= node, and =bol=.  =bol= is the
beginning-of-line buffer position. /matcher/ returns non-nil when the rule applies and /anchor/
returns the buffer position which along with /offset/ determine the indent level of the line.

Let's take this basic example of our LANGUAGE, =if_else.lang= file

#+begin_example
  if a > 1
      b = a * 2;
  else    
      b = a;
  end
#+end_example

Running =M-x treesit-explore-mode= gives us:

#+begin_example
  (source_file
   (if_statement if
    condition: (comparison_operator (identifier) > (number))
    \n
    (block
     (assignment left: (identifier) =
      right: (binary_operator left: (identifier) * right: (number)))
     ;)
    (else_clause else \n
     (block
      (assignment left: (identifier) = right: (identifier))
      ;))
    end)
   \n)
#+end_example

We start with

#+begin_src emacs-lisp
  (defvar tmp-debug-indent-rule
    '((lambda (node parent bol)
      (message "-->N:%S P:%S BOL:%S GP:%S NPS:%S"
               node parent bol
               (treesit-node-parent parent)
               (treesit-node-prev-sibling node))
        nil)
      nil
      0))

  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ,tmp-debug-indent-rule
       ((parent-is "^source_file$") column-0 0)
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

We set

: M-: (setq treesit--indent-verbose t)

and then hit the =TAB= key when vising a our =if_else.lang= file.

The first rule, =((parent-is "source_file") column-0 0)= is the rule for the root node, which in our
LANGUAGE is "source_file" and says to sart on column 0.

The two lambda debugging rules aid in writing rules will be removed when we have completed the
rules.  For example, with the above and we type =TAB= on the "b = a * 2" line in the following
=if_else.lang= file.

#+begin_example
  if a > 1
      b = a * 2;
  else    
      b = a;
  end
#+end_example

we'll see in the =*Messages*= buffer we'll see the error:

 : node: #<treesit-node block in 14-24> parent: #<treesit-node if_statement in 1-44> bol: 14

where point 14-24 is "b = a * 2" and we see it has node named "block". Thus, we update we add to our
indent rules, =((node-is "block") parent 4)= and a couple more rules as shown below.

*Tip*: =C-M-x= in our =defvar= and re-run =M-x LANGUAGE-ts-mode= file to pickup the new indent
rules.

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ,tmp-debug-indent-rule
       ((parent-is "^source_file$") column-0 0)
       ((node-is "^block$") parent 4)
       ((node-is "^else_clause$") parent 0)
       ((node-is "%end$") parent 0)
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

We can simplify this because the "else_clause" and "end" nodes have the same indent rules:

#+begin_src emacs-lisp
  (defvar LANGUAGE-ts-mode--indent-rules
    `((LANGUAGE
       ,tmp-debug-indent-rule
       ((parent-is "^source_file$") column-0 0)
       ((node-is "^block$") parent 4)
       ((node-is ,(rx bol (or "else_clause" "end") eol)) parent 0)
       ))
    "Tree-sitter indent rules for `LANGUAGE-ts-mode'.")
#+end_src

Following this process, we add additional rules and our indent engine is complete after we remove
the debugging rules.

*Tip*: If you look at the defintion, =M-x find-variable RET treesit-simple-indent-presets RET=, you
can see how the built-in /matchers/ and /achors/ are written. From that, you can write your own as
needed.

* Issues

- [ ] Building libtree-sitter-matlab.dll from src on Windows produces a DLL that fails.

  - Install MSYS2
  - Run MSYS2 bash, then: pacman -S gcc
  - Install gpg from https://www.gpg4win.org/ and place it on on the path before MSYS2.
  - Install matlab tree sitter from src using Emacs 30.1
  #+begin_example
    emacs
    M-x treesit-install-language-grammar
    Language: matlab
    There is no recipe for matlab, do you want to build it interactively? (y or n) y
    Enter the URL of the Git repository of the language grammar: https://github.com/acristoffers/tree-sitter-matlab
    Enter the tag or branch (default: default branch): abi/14
    Enter the subdirectory in which the parser.c file resides (default: "src"):
    Enter the C compiler to use (default: auto-detect):
    Enter the C++ compiler to use (default: auto-detect):
    Install to (default: ~/.emacs.d/tree-sitter):
  #+end_example

  The resulting dll is bad. Maybe gcc 13 is not a valid version of gcc.

  Note the build of the dll from https://github.com/emacs-tree-sitter/tree-sitter-langs is good.

- [ ] M-x treesit-install-language-grammar should specify the tree-sitter ABI version.

  Emacs 30.1 is ABI 14 from =(treesit-library-abi-version)=, which is behind the current tree-sitter
  version, 15.

  Emacs should do something like:

  : tree-sitter generate --abi 13
  : gcc src/*.c -I./src -o ~/.emacs.d/tree-sitter/libtree-sitter-matlab.EXT --shared -fPIC -Os

  where EXT = .dll, .so, or .dylib.

- [ ] Easy deployment?

  : M-x list-packages

  makes it easy to install packages from ELPA, MELPA, etc. but how to we get
  libtree-sitter-LANUGAGE.EXT (EXT = .so, .dll, .dylib) installed?

- [ ] In [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Parser_002dbased-Indentation.html][Parser-Based Indentation]] we have prev-line which goes backward exactly one line

  Consider a programming lanugage with a few statements, e.g.

  #+begin_example
    {
        a = 1;
        b = 2;


    }
  #+end_example

  If you use prev-line on the blank-line immediately after "b = 2;", you'll get the expected
  point below "b". If you use prev-line on the second blank line after "b = 2;", you'll get
  0, which is unexpected in many languages. I suspect it may be safe to just update prev-real
  line too look backwards to the first prior line with non-whitespace or if you are worried
  about compatibility, introduce:

  #+begin_src emacs-lisp
    (cons 'prev-real-line (lambda (_n _p bol &rest _)
    			(save-excursion
    			  (goto-char bol)
    			  (forward-line -1)
    			  (while (and (not (bobp))
    				      (looking-at "^[ \t]*$"))
    			    (forward-line -1))
    			  (skip-chars-forward " \t")
    			  (point))))
  #+end_src
