* Goal
The goal is to generate a math practice sheet made up of dynamic
problems that are defined based on flexible templates. The problem
distribution and order is also configurable.

Similar to https://www.math-aids.com.
* Problem Templates
** Overview
This section contains some example templates. Each table defines a
worksheet. Each time the worksheet is generated the problems are
re-randomized.

The table contains the following columns:
- weight :: the relative number of this type of problem to include on
  the worksheet.
- order :: problems are ordered on the sheet in ascending order. two
  problems with the same order will be intermingled.
- template :: this is the template used to generate problems of this
  type. Templates are described in more detail below.
- descr :: just notes, not used in worksheet generation.

Templates are problems but the numbers are replaced with placeholders
in square brackets.
- [0..10] :: any number from 0 to 10
- [a=...] :: assign the variable a to the number chosen for this field
- [1,3,5] :: choose 1 or 3 or 5
- [10/(2-1)] :: evaluate the expression
- [-2..$a] :: any number from -2 to the value assigned to a in another
  placeholder
- [0..[$a/2]] :: placeholders can be embedded within placeholders

** Examples

We label the table so that we can refer to it from the dynamic block
that generates the worksheet. Only the first three columns are used.

#+name: firstset
| weight | order | template                      | descr                        |
|--------+-------+-------------------------------+------------------------------|
|      3 |     1 | [1..10] + [0..10]             | simple                       |
|      2 |     2 | [1..10] + [8..15]             | second number bigger         |
|      1 |     2 | [a=3..10] - [0..$a]           | subtraction                  |
|      1 |     3 | [1..10] + [1..7] + [1..5]     | three terms                  |
|      1 |     4 | [a=1..10] + [0..10] - [0..$a] | three terms with subtraction |
|      0 |     0 | [$a*[1..5]] / [a=1..10]       | division                     |

* Code walkthrough
** Problem generation
*** Dependencies
This package needs [[https://elpa.gnu.org/packages/peg.html][peg]].

#+begin_src elisp :tangle mathsheet.el
  (require 'peg)
#+end_src

*** Variables
Need ~ianxm/var-list~ to keep track of the variables between fields.

~worksheet-template~ is the LaTeX template for the worksheet.

#+name: variables
#+begin_src elisp :tangle mathsheet.el :var page=page
  (defvar ianxm/var-list '()
    "List of variables used in a problem")

  (defconst ianxm/worksheet-template page
    "LaTeX template for worksheet")
#+end_src
*** Scan problem

must call with point at the start of a problem. moves the point to the
end of the problem. returns a list of fields, formatted as:

#+begin_example
'(var (deps) start-marker end-marker nil)
#+end_example

change to

#+begin_example
'(asn-var (deps) (start-marker . end-marker) nil)
#+end_example

~asn-var~ is a variable name if there is an assignment, otherwise it is a
placeholder like ~_0~, ~_1~, etc. ~asn-var~ must be interned and must
be the first index since we use this list as an alist later.

~alg-vars~ are algebraic variables if there are any in this problem,
otherwise ~nil~.

~start-marker~ and ~end-marker~ are markers in the (temp) buffer.

The last entry is ~nil~ for "not visited." It is used by ~dfs-visit~.

for example:
#+begin_example
[$a + 2 + [a=1..5]] => '((nil (a) m1 m19 nil) (a nil m11 m18 nil))
#+end_example

This uses the peg package to parse the problem. Instead of using the
peg return value we build the list of fields outside of the peg stack.

~open-fields~ is a stack of fields with the current field on top. We
push a new field to the stack when we start a new field.
~closed-fields~ is a list of fields that have been completed. We push a
new field to the list when we close the current field.

#+name: scan-problem
#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/scan-problem ()
    "Scan problem"
    (let ((field-index 0)
          open-fields ; stack
          closed-fields ; list
          alg-vars)

      (with-peg-rules
          ((stuff (* (or asn-var alg-var digit symbol field space)))
           (field open (opt assignment) stuff close)
           (space (* [space]))
           (open (region "[")
                 `(l r -- (progn
                            (push (list
                                   (intern (concat "_" (number-to-string field-index))) ; asn-var
                                   nil ; deps
                                   (cons (copy-marker l) nil) ; start and end markers
                                   nil) ; not visited
                                  open-fields)
                            (setq field-index (1+ field-index))
                            ".")))
           (assignment (region (substring letter)) "="
                       `(l v r -- (progn
                                    (setcar
                                     (car open-fields)
                                     (intern v))
                                    ".")))
           (asn-var "$" (substring letter)
                `(v -- (progn
                         (push (intern v) (cadar open-fields))
                         ".")))
           (alg-var (substring letter)
                    `(v -- (progn
                             (push v alg-vars)
                             ".")))
           (close (region "]")
                  `(l r -- (progn
                             (setcdr (caddar open-fields) (copy-marker l t))
                             (when (> (length open-fields) 1) ; add parent to child dependency
                               (push (caar open-fields) (cadadr open-fields)))
                             (push (pop open-fields) closed-fields)
                             ".")))
           (letter [a-z])
           (digit [0-9])
           (symbol (or "." "," "+" "-" "*" "/" "(" ")" "=")))

        (peg-run (peg stuff)
                 (lambda (x) (message "failed %s" x))
                 (lambda (x)
                   (funcall x)
                   `((:fields . ,closed-fields)
                     (:alg-vars . ,alg-vars)))))))
#+end_src

test scan

#+begin_src elisp :results verbatim :noweb yes
  <<scan-problem>>

  (with-temp-buffer
    (insert "y = [1..4] + [5,7,9]")
    (goto-char (point-min))
    (ianxm/scan-problem))
#+end_src

#+RESULTS:
: ((:fields (_1 nil (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil) (_0 nil (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil)) (:alg-vars "y"))

*** Reduce field

This must be called with point at the start of a field. This moves the
point to the end of the field. This returns a list containing the
value to which the field reduces. It is wrapped in a list because
~peg-run~ returns its stack and the value is the last thing remaining on
the stack when peg completes.

This uses the peg package to parse the field. This time there
shouldn't be any fields embedded within the field. We should have
already evaluated and replaced them.

#+name: reduce-field
#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/reduce-field ()
    (with-peg-rules
        ((field "[" space (or range sequence assignment expression value) space "]")
         (expression (list value space operation space value (* space operation space value))
                     `(vals -- (string-to-number
                                (calc-eval
                                 (mapconcat
                                  (lambda (x) (if (numberp x) (number-to-string x) x))
                                  vals
                                  " ")))))
         (operation (substring (or "+" "-" "*" "/")))
         (assignment var-lhs space "=" space (or range sequence)
                     `(v r -- (progn
                                (push (cons (intern v) r) ianxm/var-list)
                                r)))
         (range value ".." value
                `(min max -- (+ (random (- max min)) min)))
         (sequence (list value "," value (* "," value))
                   `(vals -- (seq-random-elt vals)))
         (value (or (substring (opt "-") (+ digit)) var-rhs parenthetical)
                `(v -- (if (stringp v) (string-to-number v) v)))
         (parenthetical "(" expression ")")
         (var-lhs (substring letter)) ; var for assignment
         (var-rhs "$" (substring letter) ; var for use
                  `(v -- (let ((val (alist-get (intern v) ianxm/var-list)))
                           (or val (error "var %s not set" v)))))
         (space (* [space]))
         (letter [a-z])
         (digit [0-9]))

      (peg-run (peg field)
               (lambda (x) (message "failed %s" x))
               (lambda (x) (funcall x)))))
#+end_src

test with

#+begin_src elisp :results verbatim :noweb yes :var page=page
  <<variables>>
  <<reduce-field>>

  (with-temp-buffer
      (insert "[1..4]")
      (goto-char (point-min))
      (ianxm/reduce-field))
#+end_src

#+RESULTS:
: (1)

*** Replace field

Replace a field with the value returned from reducing it.

#+name: replace-field
#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/replace-field (node)
    (let ((start (caaddr node))
          (end (1+ (cdaddr node)))
          val)
      (goto-char start)
      (when (looking-at "\\[")
        (setq val (car (ianxm/reduce-field)))
        (goto-char start)
        (delete-char (- end start) t)
        (insert (number-to-string val)))))
#+end_src

*** DFS visit

This uses a depth first search to ensure that we visit (reduce and
replace) the fields in dependency order. Check dependencies then visit
the node.

#+name: dfs-visit
#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/dfs-visit (node fields)
    (pcase (cadddr node)
      (1 (error "cycle detected")) ; cycle
      (2)                          ; skip
      (_                           ; process
       (setcar (cdddr node) 1)     ; started
       (let ((deps (cadr node)))
         (dolist (dep deps)
           (ianxm/dfs-visit
            (assq dep fields)
            fields)))
       (ianxm/replace-field node) ; visit
       (setcar (cdddr node) 2)))) ; mark done
#+end_src

*** Fill fields in problem

processes all fields in a problem.

#+begin_example
(full-problem (buffer-substring (point-at-bol) (point-at-eol)))
#+end_example

#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/fill-problem (full-problem)
      (with-temp-buffer
        ;; stage problem in temp buffer
        (insert full-problem)
        (beginning-of-buffer)

        ;; find fields, assignment variables, algebraic variables, dependencies
        (let* ((scan-ret (ianxm/scan-problem))
               (fields (alist-get :fields scan-ret))
               (alg-vars (alist-get :alg-vars scan-ret)))

          ;; visit fields ordered according to dependencies
          (dolist (node fields)
            (ianxm/dfs-visit node fields))
          (setq ianxm/var-list '())

          ;; return filled problem
          `((:problem . ,(buffer-string))
            (:alg-vars . ,alg-vars)))))
#+end_src

test with this
#+begin_src elisp :results verbatim :noweb yes :var page=page
  <<variables>>
  <<scan-problem>>
  <<reduce-field>>
  <<replace-field>>
  <<dfs-visit>>

  (ianxm/fill-problem "[1..12] + [1,4,6,10]")
  ;;(ianxm/fill-problem "[1..[2..[10..100]]]")
  ;;(ianxm/fill-problem "[$a*[1..10]] / [a=1..10]")
  ;;(ianxm/fill-problem "[$a]/(3+[a=1..5])")
  ;; (ianxm/fill-problem "1/x + 2 = [-10..[10..20]]")

#+end_src

#+RESULTS:
: ((:problem . "6 + [1,4,6,10]") (:alg-vars))

other examples
#+begin_example
  simple range
  [10..11]

  complex range
  [-10..[10..20]]

  complex with assignment
  [a=1..[2..8]]

  complex with inner assignment
  [-10..[b=10..20]]

  simple with variable
  [0..[$a..$b]]
#+end_example

*** Generate problem set from templates

1. load table
2. determine how many of each
   1. sort by weight, low to high
   2. for each row
      1. calculate number, round with min 1, but 0->0
   3. for last entry (highest weight) just take however many are left.
   4. produce '(order template nil) for each problem
   5. convert to '(order problem answer)
3. sort
4. loop through list, replacing entry with '(problem . solution)

#+name: generate-problems
#+begin_src elisp :tangle mathsheet.el
  (defun ianxm/generate-problems (template-name count)
    (let (total-weight templates problems)
      (save-excursion
        (goto-char (point-min))
        (search-forward-regexp (org-babel-named-data-regexp-for-name template-name) nil t)
        ;; read table from buffer, drop header, convert fields to numbers or strings
        (setq templates (mapcar
                         (lambda (row) (list (string-to-number (nth 0 row))
                                             (string-to-number (nth 1 row))
                                             (substring-no-properties (nth 2 row))))
                         (seq-drop (org-table-to-lisp) 2))))
      ;; sort by weight (low to high)
      (setq templates (sort templates (lambda (a b) (< (car a) (car b))))
            ;; calc total weight
            total-weight (float
                          (seq-reduce (lambda (total item) (+ total (car item)))
                                      templates
                                      0)))
      ;; calculate number for each row
      (dotimes (ii (length templates) problems)
        (let* ((item (nth ii templates))
               (weight (car item))
               (needed (cond ; number of problems to add for this template
                        ((= weight 0)
                         0)
                        ((= ii (1- (length templates)))
                         (- count (length problems)))
                        (t
                         (max (round (* (/ weight total-weight) count) ) 1))))
               problem answer)

          (let ((added 0)
                (dup-count 0)
                problem-set
                fill-ret problem solution)
            (while (< added needed) ; add until "needed" are kept
              (let* ((fill-ret (ianxm/fill-problem (caddr item)))
                     (problem (alist-get :problem fill-ret))
                     (alg-vars (alist-get :alg-vars fill-ret))
                     (calc-string (if (not alg-vars)
                                      problem
                                    (format "solve(%s,[%s])" problem (string-join alg-vars ","))))
                     (solution
                      (replace-regexp-in-string (rx (or "[" ".]" "]"))
                                                ""
                                                (calc-eval calc-string))))
                (cond
                 ((member problem problem-set) ; dedup problems
                  (setq dup-count (1+ dup-count))
                  (when (> dup-count 100)
                    ;; high number of dups indicates a narrow problem space relative to problem count
                    (error "Giving up, too many dups")))
                 (t
                  (push problem problem-set)
                  (push (list problem ; problem
                              solution ; solution
                              (cadr item) ; order
                              (not (null alg-vars))) ; true if algebraic variables exist
                        problems)
                  (setq added (1+ added)))))))))

      ;; shuffle
      (dotimes (ii (- (length problems) 1))
        (let ((jj (+ (random (- (length problems) ii)) ii)))
          (psetf (elt problems ii) (elt problems jj)
                 (elt problems jj) (elt problems ii))))

      ;; sort by order
      (sort problems (lambda (a b) (< (caddr a) (caddr b))))

      ;; return problems and answers, drop header
      problems))
#+end_src

** Update problem-set block

This generates a problem set and writes it to the dynamic block. This
is triggered by C-c C-c on the dynamic block header.

~params~ is a property list of params on the block header line
I need to extract the values

- :templates :: templates
- :count :: 10

#+begin_src elisp :tangle mathsheet.el
  (defun org-dblock-write:problem-set (params)
    "Update problem-set block and optionally write a worksheet."

    ;; write the table header
    (insert "| problem | answer |\n")
    (insert "|-\n")

    ;; generate problem set
    (let ((problems (ianxm/generate-problems
                     (plist-get params :templates)
                     (plist-get params :count))))

      ;; for each problem, write a row to the table
      (insert
       (mapconcat
        (lambda (problem) (format "|%s|%s|"
                                  (car problem)
                                  (cadr problem)))
        problems
        "\n"))

      ;; align table
      (org-table-align)

      ;; should we generate the sheet?
      (when (y-or-n-p "Write worksheet? ")
        (ianxm/gen-worksheet
         (plist-get params :templates)
         (plist-get params :instruction)
         problems))))
#+end_src

** Generate PDF
*** Lay out page
this wraps the problems with a tex header and footer.

solution for how to enumerate with circled numbers from [[https://latex.org/forum/viewtopic.php?p=40006&sid=d202f756313add2391c3140fbeafe2ff#p40006][here]]

#+name: page
#+begin_src latex :results value silent
  \documentclass[12pt]{article}
  \usepackage[top=1in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
  \usepackage{fancyhdr}
  \newsavebox{\myheadbox}% Heading storage box
  \usepackage{multicol}
  \usepackage{rotating}
  \usepackage{xcolor}
  \usepackage{enumitem}
  \usepackage{tikz}
  \newcommand*\circled[1]{%
    \tikz[baseline=(C.base)]\node[draw,circle,inner sep=1.2pt,line width=0.2mm,](C) {#1};}
  \newcommand*\CircledItem{%
    \stepcounter{enumi}\item[\circled{\theenumi}]}

  \pagestyle{fancy}
  \lhead{\textmd{\textsf{Name: }}}
  \rhead{\textmd{\textsf{Date: \today}}}
  \cfoot{}


  \begin{document}

  \noindent\textbf{<<instruction>>}
  \vspace{.2cm}
  \renewcommand{\familydefault}{\ttdefault}

    \begin{multicols}{2}
      \begin{enumerate}[itemsep=0.5cm]
        <<problems>>
      \end{enumerate}
    \end{multicols}

    \vspace*{\fill}

    \vspace*{0.1cm}
    \noindent\rule{\linewidth}{0.4pt}
    \vspace*{0.1cm}

    \begin{turn}{180}
      \begin{minipage}{\linewidth}
        \color{gray}
        \footnotesize
        \begin{multicols}{4}
          \begin{enumerate}
            <<answers>>
          \end{enumerate}
        \end{multicols}
      \end{minipage}
    \end{turn}

  \end{document}
#+end_src
*** Write PDF

This writes the generated into a local file and runs ~texi2pdf~ to
convert it to a pdf. We save it as ~worksheet.tex~ and the final
worksheet is named ~worksheet.pdf~. Each execution will overwrite the
same file.

#+begin_src elisp :results silent :tangle mathsheet.el
  (defun ianxm/gen-worksheet (template-name instruction problems)
    (with-temp-file (concat template-name ".tex")
      (insert ianxm/worksheet-template)

      (goto-char (point-min))
      (search-forward "<<instruction>>")
      (replace-match "")
      (insert instruction)

      (goto-char (point-min))
      (search-forward "<<problems>>")
      (replace-match "")
      (dolist (row problems)
        (if (cadddr row)
            (insert (format"\\CircledItem %s\\vspace{4cm}\n"
                       (car row)))
          (insert (format"\\CircledItem %s = \\rule[-.2\\baselineskip]{2cm}{0.4pt}\n"
                         (car row)))))

      (goto-char (point-min))
      (search-forward "<<answers>>")
      (replace-match "")
      (dolist (row problems)
        (insert (format "\\CircledItem %s\n"
                        (cadr row)))))
    (shell-command (concat "texi2pdf " template-name ".tex")
                   (get-buffer-create "*Standard output*")))
#+end_src
