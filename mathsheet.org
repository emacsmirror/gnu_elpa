* TODO rename to org-mathsheet.el
* Overview
** Description
This is a math worksheet generator. The worksheets are randomly
generated based on templates that define what kinds of problems to
include along with the order and relative frequency that each type of
problem should appear on the worksheet.
** Audience
This could be useful for anyone that wants to provide math practice to
someone else. It could be useful for a teacher, tutor, homeschool
parent, or any parent.
** Examples
Here are some example worksheets generated by this tool:
1. arithmatic
2. algebra
** Parts
There are two main components involved in generating a worksheet:
1. the problem templates
2. the problem-set block
*** Problem Templates
**** Expression Templates
The worksheet is made of a set of math problems. Each problem is
defined by a template that lays out an equation or expression and
shows where variables or numbers should be. For example, consider this
template:
#+begin_example
[0..15] + [1..10]
#+end_example
The parts within the brackets are fields. When a template is made into
a problem and added to a worksheet, each field is replaced by a number
based on a set of rules. The supported rules are described in more
detail below, but ~[0..15]~ means pick a random number between 0 and 15,
inclusive, so the above template could result in problems like these:
#+begin_example
1 + 2
15 + 10
5 + 1
#+end_example
**** Equation Templates
In additon to expressions where the answer is a number, templates can
be equations where the solution is found by solving for the
variable. For example, consider this template:
#+begin_example
[1..5] x + [0..10] = [-10..10]
#+end_example
This can produce the following problems:
#+begin_example
3 x + 6 = -1
4 x + 2 = 2
1 x + 8 = -3
#+end_example
**** Field Rules
These are the field rules:
- [-2..8] :: choose a random number from -2 to 8, inclusive
- [1,3,5] :: choose randomly from 1, 3 or 5
- [-3..-1,1..3] :: choose a random number from -3 to -1 or 1 to 3
- [10/(2-1)] :: evaluate the expression
- [a=...] :: assign the variable a to the number chosen for this field
- [-2..$a] :: any number from -2 to the value assigned to ~a~ in another
  field
- [0..[$a/2]] :: any number from 0 to half the value assigned to ~a~.

The ability to keep track of the random number chosen in one field and
use it to influence another allows the template to be written to avoid
answers that are negative or don't divide evenly.
**** Template Examples
Here are a few more examples:

Division problem that divides evenly
#+begin_example
[$a*[1..5]] / [a=1..10]
#+end_example

Addition and subtraction, still with a positive result
#+begin_example
[a=1..10] + [b=0..10] - [0..($a+$b)]
#+end_example

*** The Problem Template Table

You may want to have more than one type of problem on a worksheet, so

Each table defines a worksheet. Each time the worksheet is generated
the problems are re-randomized.

The table contains the following columns:
- weight :: the relative number of this type of problem to include on
  the worksheet.
- order :: problems are ordered on the sheet in ascending order. two
  problems with the same order will be intermingled.
- template :: this is the template used to generate problems of this
  type. Templates are described in more detail below.
- descr :: just your notes, not used in worksheet generation.

**** Examples

We label the table so that we can refer to it from the dynamic block
that generates the worksheet. Only the first three columns are used.

#+name: firstset
| weight | order | template                      | descr                        |
|--------+-------+-------------------------------+------------------------------|
|      3 |     1 | [1..10] + [0..10]             | simple                       |
|      2 |     2 | [1..10] + [8..15]             | second number bigger         |
|      1 |     2 | [a=3..10] - [0..$a]           | subtraction                  |
|      1 |     3 | [1..10] + [1..7] + [1..5]     | three terms                  |
|      1 |     4 | [a=1..10] + [0..10] - [0..$a] | three terms with subtraction |
|      0 |     0 | [$a*[1..5]] / [a=1..10]       | division                     |
*** Problem-Set Block
**** Overview
**** Examples
* Code walkthrough
** Problem generation
*** Header
#+begin_src elisp :tangle mathsheet.el
;;; mathsheet.el --- Generate dynamic math worksheets  -*- lexical-binding:t -*-
#+end_src

*** Dependencies
This package needs [[https://elpa.gnu.org/packages/peg.html][peg]].

#+begin_src elisp :tangle mathsheet.el
  (require 'peg)
#+end_src

*** Variables
Need ~mathsheet--var-list~ to keep track of the variables between fields.

~worksheet-template~ is the LaTeX template for the worksheet.

#+name: variables
#+begin_src elisp :tangle mathsheet.el :var page=page
  (defvar mathsheet--var-list '()
    "List of variables used in a problem")

  (defconst mathsheet--worksheet-template page
    "LaTeX template for the worksheet")
#+end_src
*** Scan problem

must call with point at the start of a problem. moves the point to the
end of the problem. returns a list of fields, formatted as:

#+begin_example
'(var (deps) start-marker end-marker nil)
#+end_example

change to

#+begin_example
'(asn-var (deps) (start-marker . end-marker) nil)
#+end_example

~asn-var~ is a variable name if there is an assignment, otherwise it is a
placeholder like ~_0~, ~_1~, etc. ~asn-var~ must be interned and must
be the first index since we use this list as an alist later.

~alg-vars~ are algebraic variables if there are any in this problem,
otherwise ~nil~.

~start-marker~ and ~end-marker~ are markers in the (temp) buffer.

The last entry is ~nil~ for "not visited." It is used by ~dfs-visit~.

for example:
#+begin_example
[$a + 2 + [a=1..5]] => '((nil (a) m1 m19 nil) (a nil m11 m18 nil))
                       '((:fields (_0 (a a) (marker . marker) nil) (a nil (marker . marker) nil)) (:alg-vars))
#+end_example

This uses the peg package to parse the problem. Instead of using the
peg return value we build the list of fields outside of the peg stack.

~open-fields~ is a stack of fields with the current field on top. We
push a new field to the stack when we start a new field.
~closed-fields~ is a list of fields that have been completed. We push a
new field to the list when we close the current field.

#+name: scan-problem
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--scan-problem ()
    "Scan a problem.

  This parses the problem and produces a list containing info about
  its fields. For each field it returns a list containing:
  1. a symbol for the assigned variable or a unique placeholder
  2. a list of variables this field depends on
  3. a cons containing start and end markers for the field in the current buffer
  4. `nil' which is used by `dfs-visit' later"
    (let ((field-index 0)
          open-fields ; stack
          closed-fields ; list
          alg-vars)

      (with-peg-rules
          ((stuff (* (or asn-var math-func alg-var digit symbol field space)))
           (field open (opt assignment) stuff close)
           (space (* [space]))
           (open (region "[")
                 `(l _ -- (progn
                            (push (list
                                   (intern (concat "_" (number-to-string field-index))) ; asn-var
                                   nil ; deps
                                   (cons (copy-marker l) nil) ; start and end markers
                                   nil) ; not visited
                                  open-fields)
                            (setq field-index (1+ field-index))
                            ".")))
           (assignment (substring letter) "="
                       `(v -- (progn
                                (setcar
                                 (car open-fields)
                                 (intern v))
                                ".")))
           (asn-var "$" (substring letter)
                    `(v -- (progn
                             (push (intern v) (cadar open-fields))
                             ".")))
           (alg-var (substring letter)
                    `(v -- (progn
                             (push v alg-vars)
                             ".")))
           (close (region "]")
                  `(l _ -- (progn
                             (setcdr (caddar open-fields) (copy-marker l t))
                             (when (> (length open-fields) 1) ; add parent to child dependency
                               (push (caar open-fields) (cadadr open-fields)))
                             (push (pop open-fields) closed-fields)
                             ".")))
           (math-func (or "sqrt" "sin" "cos" "tan" "asin" "acos" "atan" "floor" "ceil" "round"))
           (letter [a-z])
           (digit [0-9])
           (symbol (or "." "," "+" "-" "*" "/" "^" "(" ")" "=")))

        (peg-run (peg stuff)
                 (lambda (x) (message "failed %s" x))
                 (lambda (x)
                   (funcall x)
                   `((:fields . ,closed-fields)
                     (:alg-vars . ,alg-vars)))))))
#+end_src

test scan

#+begin_src elisp :results verbatim :noweb yes
  <<scan-problem>>

  (with-temp-buffer
    (insert "[0..4,6-9,11] * x + [floor([-10..10]/3)] = [-10..10]")
    (goto-char (point-min))
    (mathsheet--scan-problem))
#+end_src

#+RESULTS:
: ((:fields (_3 nil (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil) (_1 (_2) (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil) (_2 nil (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil) (_0 nil (#<marker in no buffer> . #<marker (moves after insertion) in no buffer>) nil)) (:alg-vars "x"))

*** Reduce field

This must be called with point at the start of a field. This moves the
point to the end of the field. This returns a list containing the
value to which the field reduces. It is wrapped in a list because
~peg-run~ returns its stack and the value is the last thing remaining on
the stack when peg completes.

This uses the peg package to parse the field. This time there
shouldn't be any fields embedded within the field. We should have
already evaluated and replaced them.

We use ~..~ insead of ~-~ for range because if we used ~-~ then this would
be ambiguous:
#+begin_example
[1-5]
#+end_example

#+name: reduce-field
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--reduce-field ()
    "Reduce the field to a number.

  Parse the field again, replacing spans with random numbers and
  evaluating arithmetic operations. The field shouldn't have any
  internal fields so this should result in a single number. Return
  that number."
    (with-peg-rules
        ((field "[" space (or math-func expression sequence assignment value) space "]")
         (expression (list value space operation space value (* space operation space value))
                     `(vals -- (string-to-number
                                (calc-eval
                                 (list
                                  (mapconcat
                                   (lambda (x) (if (numberp x) (number-to-string x) x))
                                   vals
                                   " "))
                                 calc-prefer-frac nil))))
         (operation (substring (or "+" "-" "*" "/")))
         (assignment var-lhs space "=" space (or range sequence)
                     `(v r -- (progn
                                (push (cons (intern v) r) mathsheet--var-list)
                                r)))
         (sequence (list (or range value) (* "," space (or range value)))
                   `(vals -- (seq-random-elt vals)))
         (range value ".." value
                `(min max -- (+ (random (- max min)) min)))
         (value (or (substring (opt "-") (+ digit)) var-rhs parenthetical)
                `(v -- (if (stringp v) (string-to-number v) v)))
         (parenthetical "(" (or expression value) ")")
         (var-lhs (substring letter)) ; var for assignment
         (var-rhs "$" (substring letter) ; var for use
                  `(v -- (let ((val (alist-get (intern v) mathsheet--var-list)))
                           (or val (error "var %s not set" v)))))
         (math-func (substring (or "sqrt" "sin" "cos" "tan" "asin" "acos" "atan" "floor" "ceil" "round"))
                    parenthetical
                    `(f v -- (string-to-number (calc-eval (format "%s(%s)" f v)))))
         (space (* [space]))
         (letter [a-z])
         (digit [0-9]))

      (peg-run (peg field)
               (lambda (x) (message "failed %s" x))
               (lambda (x) (car (funcall x))))))
#+end_src

test with

#+begin_src elisp :results verbatim :noweb yes :var page=page
  <<variables>>
  <<reduce-field>>

  (with-temp-buffer
    ;(insert "[1..10,15..20,50]")
    (insert "[1..10]")
      (goto-char (point-min))
      (mathsheet--reduce-field))
#+end_src

#+RESULTS:
: 8

*** Replace field

Replace a field with the value returned from reducing it.

#+name: replace-field
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--replace-field (node)
    "Replace a field with the number to which it reduces

  Update the current buffer by replacing the field at point in the
  current buffer with the number it reduces to. NODE contains the
  info for the current field."
    (let ((start (caaddr node))
          (end (1+ (cdaddr node)))
          val)
      (goto-char start)
      (when (looking-at "\\[")
        (setq val (mathsheet--reduce-field))
        (goto-char start)
        (delete-char (- end start) t)
        (insert (number-to-string val)))))
#+end_src

*** DFS visit

This uses a depth first search to ensure that we visit (reduce and
replace) the fields in dependency order. Check dependencies then visit
the node.

#+name: dfs-visit
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--dfs-visit (node fields)
    "Visit NODE as part of a DFS of the problem

  Traverse the fields of a problem using depth first search to
  ensure that field replacement happens in dependency order. FIELDS
  is a list of all fields in the problem."
    (pcase (cadddr node)
      (1 (error "cycle detected")) ; cycle
      (2)                          ; skip
      (_                           ; process
       (setcar (cdddr node) 1)     ; started
       (let ((deps (cadr node)))
         (dolist (dep deps)
           (mathsheet--dfs-visit
            (assq dep fields)
            fields)))
       (mathsheet--replace-field node) ; visit
       (setcar (cdddr node) 2)))) ; mark done
#+end_src

*** Fill fields in problem

processes all fields in a problem.

#+begin_example
(full-problem (buffer-substring (point-at-bol) (point-at-eol)))
#+end_example

#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--fill-problem (full-problem)
    "Replace all fields in FULL-PROBLEM

  Goes through all fields in the given problem in dependency order
  and replaces fields with numbers. When this completes the problem
  will be ready to solve."
      (with-temp-buffer
        ;; stage problem in temp buffer
        (insert full-problem)
        (goto-char (point-min))

        ;; find fields, assignment variables, algebraic variables, dependencies
        (let* ((scan-ret (mathsheet--scan-problem))
               (fields (alist-get :fields scan-ret))
               (alg-vars (alist-get :alg-vars scan-ret)))

          ;; visit fields ordered according to dependencies
          (dolist (node fields)
            (mathsheet--dfs-visit node fields))
          (setq mathsheet--var-list '())

          ;; return filled problem
          `((:problem . ,(buffer-string))
            (:alg-vars . ,alg-vars)))))
#+end_src

test with this
#+begin_src elisp :results verbatim :noweb yes :var page=page
  <<variables>>
  <<scan-problem>>
  <<reduce-field>>
  <<replace-field>>
  <<dfs-visit>>

  (mathsheet--fill-problem "[1..12] + [1,4,6,10]")
  ;;(mathsheet--fill-problem "[1..[2..[10..100]]]")
  ;;(mathsheet--fill-problem "[$a*[1..10]] / [a=1..10]")
  ;;(mathsheet--fill-problem "[$a]/(3+[a=1..5])")
  ;; (mathsheet--fill-problem "1/x + 2 = [-10..[10..20]]")

#+end_src

#+RESULTS:
: ((:problem . "6 + [1,4,6,10]") (:alg-vars))

other examples
#+begin_example
  simple range
  [10..11]

  complex range
  [-10..[10..20]]

  complex with assignment
  [a=1..[2..8]]

  complex with inner assignment
  [-10..[b=10..20]]

  simple with variable
  [0..[$a..$b]]
#+end_example

*** Generate problem set from templates

1. load table
2. determine how many of each
   1. sort by weight, low to high
   2. for each row
      1. calculate number, round with min 1, but 0->0
   3. for last entry (highest weight) just take however many are left.
   4. produce '(order template nil) for each problem
   5. convert to '(order problem answer)
3. sort
4. loop through list, replacing entry with '(problem . solution)

#+name: generate-problems
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--generate-problems (template-name count)
    "Generate COUNT problems based on TEMPLATE-NAME

  Generate problems and answers based on what is defined in the
  given template table. The template table defines problem
  templates as well as relative weights and how they should be
  ordered."
    (let (total-weight templates problems)
      (save-excursion
        (goto-char (point-min))
        (search-forward-regexp (org-babel-named-data-regexp-for-name template-name) nil t)
        ;; read table from buffer, drop header, convert fields to numbers or strings
        (setq templates (mapcar
                         (lambda (row) (list (string-to-number (nth 0 row))
                                             (string-to-number (nth 1 row))
                                             (substring-no-properties (nth 2 row))))
                         (seq-drop (org-table-to-lisp) 2))))
      ;; sort by weight (low to high)
      (setq templates (sort templates (lambda (a b) (< (car a) (car b))))
            ;; calc total weight
            total-weight (float
                          (seq-reduce (lambda (total item) (+ total (car item)))
                                      templates
                                      0)))
      ;; calculate number for each row
      (dotimes (ii (length templates))
        (let* ((item (nth ii templates))
               (weight (car item))
               (needed (cond ; number of problems to add for this template
                        ((= weight 0)
                         0)
                        ((= ii (1- (length templates)))
                         (- count (length problems)))
                        (t
                         (max (round (* (/ weight total-weight) count) ) 1))))
               (added 0)
               (dup-count 0)
               problem-set)
          (while (< added needed) ; add until "needed" are kept
            (let* ((fill-ret (mathsheet--fill-problem (caddr item)))
                   (problem (alist-get :problem fill-ret))
                   (alg-vars (alist-get :alg-vars fill-ret))
                   (calc-string (if (not alg-vars)
                                    problem
                                  (format "solve(%s,[%s])" problem (string-join (seq-uniq alg-vars) ","))))
                   (solution
                    (replace-regexp-in-string (rx (or "[" ".]" "]"))
                                              ""
                                              (calc-eval calc-string))))
              (cond
               ((member problem problem-set) ; dedup problems
                (setq dup-count (1+ dup-count))
                (when (> dup-count 100)
                  ;; high number of dups indicates a narrow problem space relative to problem count
                  (error "Giving up, too many dups")))
               (t
                (push problem problem-set)
                (push (list problem ; problem
                            solution ; solution
                            (cadr item) ; order
                            (not (null alg-vars))) ; true if algebraic variables exist
                      problems)
                (setq added (1+ added))))))))

      ;; shuffle
      (dotimes (ii (- (length problems) 1))
        (let ((jj (+ (random (- (length problems) ii)) ii)))
          (cl-psetf (elt problems ii) (elt problems jj)
                 (elt problems jj) (elt problems ii))))

      ;; sort by order
      (sort problems (lambda (a b) (< (caddr a) (caddr b))))

      ;; return problems and answers, drop header
      problems))
#+end_src

** Update problem-set block

This generates a problem set and writes it to the dynamic block. This
is triggered by C-c C-c on the dynamic block header.

~params~ is a property list of params on the block header line
I need to extract the values

- :templates :: templates
- :count :: 10
- :instruction :: "Solve for x"

#+begin_src elisp :tangle mathsheet.el
  (defun org-dblock-write:problem-set (params)
    "Update problem-set block and optionally write a worksheet.

  PARAMS is a plist with the properties set on the dynamic block
  header, which includes `:tempates' which is the name of the
  templates table, `:count' which is the number of problems to put
  on the worksheet, and `:instruction' which is the content of the
  instruction line at the top of the page"

    ;; write the table header
    (insert "| problem | answer |\n")
    (insert "|-\n")

    ;; generate problem set
    (let ((problems (mathsheet--generate-problems
                     (plist-get params :templates)
                     (plist-get params :count))))

      ;; for each problem, write a row to the table
      (insert
       (mapconcat
        (lambda (problem) (format "| %s | %s |"
                                  (car problem)
                                  (cadr problem)))
        problems
        "\n"))

      ;; align table
      (org-table-align)

      ;; should we generate the sheet?
      (when (y-or-n-p "Write worksheet? ")
        (mathsheet--gen-worksheet
         (plist-get params :templates)
         (plist-get params :instruction)
         problems))))
#+end_src

** Generate PDF
*** Lay out page
this wraps the problems with a tex header and footer.

solution for how to enumerate with circled numbers from [[https://latex.org/forum/viewtopic.php?p=40006&sid=d202f756313add2391c3140fbeafe2ff#p40006][here]]

#+name: page
#+begin_src latex :results value silent
  \documentclass[12pt]{article}
  \usepackage[top=1in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
  \usepackage{fancyhdr}
  \newsavebox{\myheadbox}% Heading storage box
  \usepackage{multicol}
  \usepackage{rotating}
  \usepackage{xcolor}
  \usepackage{enumitem}
  \usepackage{tikz}
  \newcommand*\circled[1]{%
    \tikz[baseline=(C.base)]\node[draw,circle,inner sep=1.2pt,line width=0.2mm,](C) {#1};}
  \newcommand*\CircledItem{%
    \stepcounter{enumi}\item[\circled{\theenumi}]}

  \pagestyle{fancy}
  \lhead{\textmd{\textsf{Name: }}}
  \rhead{\textmd{\textsf{Date: \today}}}
  \cfoot{}


  \begin{document}

  \noindent\textbf{<<instruction>>}
  \vspace{.2cm}
  \renewcommand{\familydefault}{\ttdefault}

    \begin{multicols}{2}
      \begin{enumerate}[itemsep=0.5cm]
        <<problems>>
      \end{enumerate}
    \end{multicols}

    \vspace*{\fill}

    \vspace*{0.1cm}
    \noindent\rule{\linewidth}{0.4pt}
    \vspace*{0.1cm}

    \begin{turn}{180}
      \begin{minipage}{\linewidth}
        \color{gray}
        \footnotesize
        \begin{multicols}{4}
          \begin{enumerate}
            <<answers>>
          \end{enumerate}
        \end{multicols}
      \end{minipage}
    \end{turn}

  \end{document}
#+end_src
*** Convert calc to latex
Convert a calc expression to latex format.

#+name: convert-to-latex
#+begin_src elisp :tangle mathsheet.el
  (defun mathsheet--convert-to-latex (expr)
    "Format the given calc expression EXPR for LaTeX

  EXPR should be in normal calc format. The result is the same
  expression (not simplified) but in LaTeX format."
    (let* ((calc-language 'latex)
           (calc-expr (math-read-expr expr))
           (latex-expr (math-format-stack-value (list calc-expr 1 nil)))
           (latex-expr-cleaned (replace-regexp-in-string (rx "1:" (* space)) "" latex-expr)))
      (concat "$" latex-expr-cleaned "$")))
#+end_src
*** Write PDF

This writes the generated into a local file and runs ~texi2pdf~ to
convert it to a pdf. We save it as ~[template-name].tex~ and the final
worksheet is named ~[template-name].pdf~. Each execution with the same
template name will overwrite the same file.


#+begin_src elisp :results silent :tangle mathsheet.el
  (defun mathsheet--gen-worksheet (file-name instruction problems)
    "Generate a worksheet with PROBLEMS.

  Write a file named FILE-NAME. Include the INSTRUCTION line at the
  top."
    (with-temp-file (concat file-name ".tex")
      (insert mathsheet--worksheet-template)

      (goto-char (point-min))
      (search-forward "<<instruction>>")
      (replace-match "")
      (insert instruction)

      (goto-char (point-min))
      (search-forward "<<problems>>")
      (replace-match "")
      (dolist (row problems)
        (if (cadddr row)
            (insert (format"\\CircledItem %s\\vspace{4cm}\n"
                           (mathsheet--convert-to-latex (car row))))
          (insert (format"\\CircledItem %s = \\rule[-.2\\baselineskip]{2cm}{0.4pt}\n"
                         (mathsheet--convert-to-latex (car row))))))

      (goto-char (point-min))
      (search-forward "<<answers>>")
      (replace-match "")
      (dolist (row problems)
        (insert (format "\\CircledItem %s\n"
                        (mathsheet--convert-to-latex (cadr row))))))
    (shell-command (concat "texi2pdf " file-name ".tex")
                   (get-buffer-create "*Standard output*")))
#+end_src
