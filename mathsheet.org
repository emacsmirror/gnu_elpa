* goal
The goal is to generate a math practice sheet made up of dynamic problems that are defined in flexible templates.

Similar to https://www.math-aids.com.
* script
** vars
This sets the name at the top of the page as well as the number of
problems on the worksheet.

#+property: header-args+ :var student="Noble" problem-count=26

** problem set examples
This section contains some example templates. Each table defines a
worksheet. Each time the worksheet is created the problems are
generated randomly.

The table contains the following columns:
- weight :: the relative number of this type of problem to include on
  the worksheet.
- order :: problems are ordered on the sheet in ascending order. two
  problems with the same order will be intermingled.
- template :: this is the template used to generate problems of this
  type. Templates are described in more detail below.
- descr :: just notes, not used in worksheet generation.

Templates are problems but the numbers are replaced with placeholders
in square brackets.
- [0..10] :: any number from 0 to 10
- [a=...] :: assign the variable a to the number chosen for this field
- [1,3,5] :: choose 1 or 3 or 5
- [10/(2-1)] :: evaluate the expression
- [-2..$a] :: any number from -2 to the value assigned to a in another
  placeholder
- [0..[$a/2]] :: placeholders can be embedded within placeholders

*** add and subtract

#+name: firstset
| weight | order | template                      | descr                  |
|--------+-------+-------------------------------+------------------------|
|      3 |     1 | [1..10] + [0..10]             | simple                 |
|      2 |     2 | [1..10] + [8..15]             | second number bigger   |
|      1 |     2 | [a=3..10] - [0..$a]           | subtraction            |
|      1 |     3 | [1..10] + [1..7] + [1..5]     | three numbers          |
|      1 |     4 | [a=1..10] + [0..10] - [0..$a] | three with subtraction |
|      0 |     0 | [$a*[1..5]] / [a=1..10]       | division               |

** problem generation

TODO create a package. if you C-c C-c on a table
1. if you are on the header, generate a worksheet
2. if you on on a row, generate a single example

*** var-list
need ~var-list~ to keep track of the variables between fields.

#+name: var-list
#+begin_src elisp
(defvar ianxm/var-list '()
"List of variables used in a problem")
#+end_src
*** scan field

must call with point at the start of a field. moves the point to the
end of the field. returns a list of fields, formatted as:

#+begin_example
'(var (deps) start-marker end-marker nil)
#+end_example

~var~ is a variable name if there is an assignment, or it is a
placeholder like ~_0~, ~_1~, etc. the last entry is nil for "not
visited." ~var~ must be interned and must be the first index since we
use this as an alist.

~start-marker~ and ~end-marker~ are markers in the (temp) buffer.

for example:
#+begin_example
[$a + 2 + [a=1..5]] => '((nil (a) m1 m19 nil) (a nil m11 m18 nil))
#+end_example

~open-fields~ is a stack of fields with the current field on top. we
push a new field to the stack when we start a new field.
~closed-fields~ is a list of fields that have been completed. we push a
new field to the list when we close the current field.

#+name: scan-problem
#+begin_src elisp
  (defun ianxm/scan-problem ()
    (interactive)
    (let ((field-index 0)
          open-fields ; stack (open close (vars) deps)
          closed-fields) ; list (open close (vars) deps)

      (with-peg-rules
          ((stuff (* (or var letter digit symbol field space)))
           (field open (opt assignment) stuff close)
           (space (* [space]))
           (open (region "[")
                 `(l r -- (progn
                            (push (list
                                   (intern (concat "_" (number-to-string field-index)))
                                   nil (copy-marker l) nil nil)
                                  open-fields)
                            field-index (1+ field-index)
                            ".")))
           (assignment (region (substring letter)) "="
                       `(l v r -- (progn
                                    (setcar
                                     (car open-fields)
                                     (intern v))
                                    ".")))
           (var "$" (substring letter)
                `(v -- (progn
                         (push (intern v) (cadar open-fields))
                         ".")))
           (close (region "]")
                  `(l r -- (progn
                             (setcar (cdddar open-fields) (copy-marker l t))
                             (when (> (length open-fields) 1)
                               (push (caar open-fields) (cadadr open-fields)))
                             (push (pop open-fields) closed-fields)
                             ".")))
           (letter [a-z])
           (digit [0-9])
           (symbol (or "." "+" "-" "*" "/" "(" ")")))

        (peg-run (peg stuff)
                 (lambda (x) (message "failed %s" x))
                 (lambda (x)
                   (funcall x)
                   closed-fields)))))
#+end_src

*** reduce field

must call with point at the start of a field. moves point to the end
of the field. returns a list containing the value to which the field
reduces.

#+name: reduce-field
#+begin_src elisp
  (defun ianxm/reduce-field ()
    (interactive)
    (with-peg-rules
        ((field "[" space (or range sequence assignment expression value) space "]")
         (expression (list value space operation space value (* space operation space value))
                     `(vals -- (string-to-number
                                (calc-eval
                                 (mapconcat
                                  (lambda (x) (if (numberp x) (number-to-string x) x))
                                  vals
                                  " ")))))
         (operation (substring (or "+" "-" "*" "/")))
         (assignment var-lhs space "=" space (or range sequence)
                     `(v r -- (progn
                                (push (cons (intern v) r) var-list)
                                r)))
         (range value ".." value
                `(min max -- (+ (random (- max min)) min)))
         (sequence (list value "," value (* "," value))
                   `(vals -- (seq-random-elt vals)))
         (value (or (substring (opt "-") (+ digit)) var-rhs parenthetical)
                `(v -- (if (stringp v) (string-to-number v) v)))
         (parenthetical "(" expression ")"
                        (action (message "paren")))
         (var-lhs (substring letter)) ; var for assignment
         (var-rhs "$" (substring letter) ; var for use
                  `(v -- (let ((val (alist-get (intern v) var-list)))
                           (or val (error "var %s not set" v)))))
         (space (* [space]))
         (letter [a-z])
         (digit [0-9]))

      (peg-run (peg field)
               (lambda (x) (message "failed %s" x))
               (lambda (x) (funcall x)))))
#+end_src

*** replace field

replace a field with the value returned from processing it.

#+name: replace-field
#+begin_src elisp
  (defun ianxm/replace-field (node)
    (let ((start (caddr node))
          (end (1+ (cadddr node)))
          val)
      (goto-char start)
      (when (looking-at "\\[")
        (setq val (car (ianxm/reduce-field)))
        (goto-char start)
        (delete-char (- end start) t)
        (insert (number-to-string val)))))
#+end_src

*** dfs visit

check dependencies then visit the node

#+name: dfs-visit
#+begin_src elisp
  (defun ianxm/dfs-visit (node fields)
    (pcase (nth 4 node)
      (1 (error "cycle detected")) ; cycle
      (2)                          ; skip
      (_                           ; process
       (setcar (cddddr node) 1)  ; started
       (let ((deps (cadr node)))
         (dolist (dep deps)
           (ianxm/dfs-visit
            (assq dep fields)
            fields)))
       (ianxm/replace-field node) ; visit
       (setcar (cddddr node) 2)))) ; mark done
#+end_src
*** fill fields in problem

processes all fields in a problem.

#+begin_example
(full-problem (buffer-substring (point-at-bol) (point-at-eol)))
#+end_example

#+name: fill-problem
#+begin_src elisp :var full-problem="[$a + 2 + [a=1..5]]"
  (defun ianxm/fill-problem (full-problem)
      (interactive)
      (let (fields)
        (with-temp-buffer
          ;; stage problem in temp buffer
          (insert full-problem)
          (beginning-of-buffer)

          ;; find fields, assignments, dependencies
          (setq fields (ianxm/scan-problem))
          ;;(message "fields %s" fields)

          ;; order fields according to dependencies
          (dolist (node fields)
            (ianxm/dfs-visit node fields))
          (setq var-list '())
          (buffer-string))))
#+end_src

test with this
#+begin_src elisp :noweb yes
  <<full>>

  ;;(ianxm/fill-problem "[1..12] + [1..10]")
  ;;(ianxm/fill-problem "[1..[2..[10..100]]]")
  ;;(ianxm/fill-problem "[$a*[1..10]] / [a=1..10]")
  ;;(ianxm/fill-problem "[$a]/(3+[a=1..5])")
  (ianxm/fill-problem "[-10..[10..20]]")

#+end_src

#+RESULTS:
: -7

other examples
#+begin_example
  simple range
  [10..11]

  complex range
  [-10..[10..20]]

  complex with assignment
  [a=1..[2..8]]

  complex with inner assignment
  [-10..[b=10..20]]

  simple with variable
  [0..[$a..$b]]
#+end_example

*** full script
tangles everything needed to convert a template to a problem

#+name: full
#+begin_src elisp :noweb yes :tangle mathsheet.el
  <<var-list>>

  <<scan-problem>>

  <<reduce-field>>

  <<catalog-fields>>

  <<replace-field>>

  <<dfs-visit>>

  <<fill-problem>>

  <<generate-problems>>
#+end_src
** generate problem set from templates

1. load table
2. determine how many of each
   1. sort by weight, low to high
   2. for each row
      1. calculate number, round with min 1, but 0->0
   3. for last entry (highest weight) just take however many are left.
   4. produce '(order template nil) for each problem
   5. convert to '(order problem answer)
3. sort
4. loop through list, replacing entry with '(problem . solution)

#+name: generate-problems
#+begin_src elisp :results table :var templates=firstset
  (defun ianxm/generate-problems ()
    (let (total-weight problems)
      ;; sort by weight (low to high)
      (setq templates (sort templates (lambda (a b) (< (car a) (car b))))
            ;; calc total weight
            total-weight (float
                          (seq-reduce (lambda (total item) (+ total (car item)))
                                      templates
                                      0)))
      ;; calculate number for each row
      (dotimes (ii (length templates) problems)
        (let* (problem answer
                       (item (nth ii templates))
                       (weight (car item))
                       (needed (cond
                                ((= weight 0)
                                 0)
                                ((= ii (1- (length templates)))
                                 (- problem-count (length problems)))
                                (t
                                 (max (round (* (/ weight total-weight) problem-count) ) 1)))))

          ;; add just problems to list?
          ;; dedup each one
          ;; add until "needed" are kept
          (let ((added 0)
                problem-set
                problem)
            (while (< added needed)
              (setq problem (ianxm/fill-problem (caddr item)))
              (when (not (member problem problem-set))
                (push problem problem-set)
                (push (list problem (calc-eval problem) (cadr item)) problems)
                (setq added (1+ added)))))))

      ;; shuffle
      (dotimes (ii (- (length problems) 1))
        (let ((jj (+ (random (- (length problems) ii)) ii)))
          (psetf (elt problems ii) (elt problems jj)
                 (elt problems jj) (elt problems ii))))

      ;; sort by order
      (sort problems (lambda (a b) (< (caddr a) (caddr b))))

      ;; return
      problems))
#+end_src

test with this

#+name: problem-set
#+begin_src elisp :results table :noweb yes :var templates=firstset
  <<full>>

  (ianxm/generate-problems)
#+end_src

#+RESULTS: problem-set
| 9 + 9     | 18 | 1 |
| 4 + 3     |  7 | 1 |
| 6 + 9     | 15 | 1 |
| 5 + 4     |  9 | 1 |
| 1 + 4     |  5 | 1 |
| 3 + 7     | 10 | 1 |
| 4 + 7     | 11 | 1 |
| 8 + 3     | 11 | 1 |
| 2 + 0     |  2 | 1 |
| 5 + 5     | 10 | 1 |
| 9 + 3     | 12 | 1 |
| 8 + 10    | 18 | 2 |
| 6 + 10    | 16 | 2 |
| 6 - 4     |  2 | 2 |
| 7 + 10    | 17 | 2 |
| 4 + 13    | 17 | 2 |
| 6 + 14    | 20 | 2 |
| 7 - 3     |  4 | 2 |
| 8 - 6     |  2 | 2 |
| 2 + 11    | 13 | 2 |
| 9 + 1 + 4 | 14 | 3 |
| 3 + 1 + 4 |  8 | 3 |
| 1 + 1 + 4 |  6 | 3 |
| 2 + 7 - 1 |  8 | 4 |
| 9 + 1 - 1 |  9 | 4 |
| 9 + 1 - 4 |  6 | 4 |

** lay out problems and answers
this generates a problem set.

#+name: layout-problems-answers
#+begin_src elisp :results silent :noweb yes :var problem-set=problem-set problemsp='t
      (with-temp-buffer
          (dolist (row problem-set)
            (if problemsp
                (insert (format"\\CircledItem %s = \\rule[-.2\\baselineskip]{2cm}{0.4pt}\n\n"
                               (car row)))
              (insert (format "\\CircledItem %s\n\n"
                              (cadr row)))))
        (buffer-string))
#+end_src

** lay out page
this wraps the problems with a tex header and footer.

solution for how to enumerate with circled numbers from [[https://latex.org/forum/viewtopic.php?p=40006&sid=d202f756313add2391c3140fbeafe2ff#p40006][here]]

#+name: page
#+begin_src latex :results value silent :noweb yes
  \documentclass[12pt]{article}
  \usepackage[top=1in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
  \usepackage{fancyhdr}
  \newsavebox{\myheadbox}% Heading storage box
  \usepackage{multicol}
  \usepackage{rotating}
  \usepackage{xcolor}
  \usepackage{enumitem}
  \usepackage{tikz}
  \newcommand*\circled[1]{%
    \tikz[baseline=(C.base)]\node[draw,circle,inner sep=1.2pt,line width=0.2mm,](C) {#1};}
  \newcommand*\CircledItem{%
    \stepcounter{enumi}\item[\circled{\theenumi}]}

  \pagestyle{fancy}
  \lhead{\textmd{\textsf{Name: student}}}
  \rhead{\textmd{\textsf{Date: \today}}}
  \cfoot{}

  \renewcommand{\familydefault}{\ttdefault}

  \begin{document}

    \begin{multicols}{2}
      \begin{enumerate}[itemsep=0.5cm]
        <<layout-problems-answers(problemsp='t)>>
      \end{enumerate}
    \end{multicols}

    \vspace*{0.1cm}
    \noindent\rule{\linewidth}{0.4pt}
    \vspace*{0.1cm}

    \begin{turn}{180}
      \begin{minipage}{\linewidth}
        \color{gray}
        \footnotesize
        \begin{multicols}{4}
          \begin{enumerate}
            <<layout-problems-answers(problemsp='nil)>>
          \end{enumerate}
        \end{multicols}
      \end{minipage}
    \end{turn}

  \end{document}
#+end_src

* generate pdf
this writes the generated into a local file and runs ~texi2pdf~ to
convert it to a pdf.

#+begin_src elisp :results silent :var tex-content=page
  (with-temp-file "worksheet.tex"
    (insert tex-content))
  (shell-command "texi2pdf worksheet.tex"
                 (get-buffer-create "*Standard output*"))))
#+end_src
